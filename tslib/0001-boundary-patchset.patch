From 28e86cab310717a717d0723b74f0eba452179b20 Mon Sep 17 00:00:00 2001
From: Troy Kisky <troy.kisky@boundarydevices.com>
Date: Tue, 1 May 2012 11:33:22 -0700
Subject: [PATCH] boundary patchset

plugins: add linear_quad

src: add tsquadrant_cal

tests: add ts_calibrate_quadrant

tests: add autogenerated script ts_calibrate_quadrant

test:ts_test: don't print debug samples

plugins:input-raw: allow to work with older tslib programs

default to using linear_quad instead of linear

add linear_quad filter

Update the INSTALL file to the latest from autotools.

add 9 point calibration

ts_calibrate_quadrant: remove USE_INPUT_API reference

ts_calibrate_quadrant: add pointercal_c file output

tsquadrant_cal: remove non-float implementation since it doesn't have enough resolution, check for npoints <6

Signed-off-by: Troy Kisky <troy.kisky@boundarydevices.com>

ts_calibrate_quadrant: add -x option to output x11 settings

Signed-off-by: Troy Kisky <troy.kisky@boundarydevices.com>

ts_calibrate_quadrant: add rotate180 option

Signed-off-by: Troy Kisky <troy.kisky@boundarydevices.com>

fbutils: fix rotate180 off by 1 issue

Signed-off-by: Troy Kisky <troy.kisky@boundarydevices.com>

ts_open: add ts_open_config function to pick most likely touchscreen device

Signed-off-by: Troy Kisky <troy.kisky@boundarydevices.com>

ts_test: call ts_open_config

Signed-off-by: Troy Kisky <troy.kisky@boundarydevices.com>

ts_calibrate_quadrant: call ts_open_config

Signed-off-by: Troy Kisky <troy.kisky@boundarydevices.com>

rm file built by configure tests/ts_calibrate_quadrant

Signed-off-by: Troy Kisky <troy.kisky@boundarydevices.com>

ts_open: use ts_open_config/add xres/yres param to ts_open

Signed-off-by: Troy Kisky <troy.kisky@boundarydevices.com>

Add general rotation options 0-7

Signed-off-by: Troy Kisky <troy.kisky@boundarydevices.com>

fix rotate right/left directions to match xrand

Signed-off-by: Troy Kisky <troy.kisky@boundarydevices.com>

ts_open: restore ts_open availability

Signed-off-by: Troy Kisky <troy.kisky@boundarydevices.com>
---
 INSTALL                       |  199 ++++++--
 configure.ac                  |    1 +
 etc/ts.conf                   |    5 +-
 plugins/Makefile.am           |   11 +
 plugins/input-raw.c           |   28 +-
 plugins/linear_quad.c         |  369 +++++++++++++++
 src/Makefile.am               |    4 +-
 src/ts_open.c                 |  142 +++++-
 src/tslib-private.h           |    2 +
 src/tslib.h                   |    1 +
 src/tsquadrant_cal.c          | 1009 +++++++++++++++++++++++++++++++++++++++++
 src/tsquadrant_cal.h          |   39 ++
 tests/Makefile.am             |    9 +-
 tests/fbutils.c               |   29 +-
 tests/fbutils.h               |   11 +-
 tests/ts_calibrate.c          |   21 +-
 tests/ts_calibrate_quadrant.c |  331 ++++++++++++++
 tests/ts_harvest.c            |   22 +-
 tests/ts_print.c              |   20 +-
 tests/ts_print_raw.c          |   20 +-
 tests/ts_test.c               |   85 +++-
 21 files changed, 2227 insertions(+), 131 deletions(-)
 create mode 100644 plugins/linear_quad.c
 create mode 100644 src/tsquadrant_cal.c
 create mode 100644 src/tsquadrant_cal.h
 create mode 100644 tests/ts_calibrate_quadrant.c

diff --git a/INSTALL b/INSTALL
index 5458714..7d1c323 100644
--- a/INSTALL
+++ b/INSTALL
@@ -2,18 +2,24 @@ Installation Instructions
 *************************
 
 Copyright (C) 1994, 1995, 1996, 1999, 2000, 2001, 2002, 2004, 2005,
-2006 Free Software Foundation, Inc.
+2006, 2007, 2008, 2009 Free Software Foundation, Inc.
 
-This file is free documentation; the Free Software Foundation gives
-unlimited permission to copy, distribute and modify it.
+   Copying and distribution of this file, with or without modification,
+are permitted in any medium without royalty provided the copyright
+notice and this notice are preserved.  This file is offered as-is,
+without warranty of any kind.
 
 Basic Installation
 ==================
 
-Briefly, the shell commands `./configure; make; make install' should
+   Briefly, the shell commands `./configure; make; make install' should
 configure, build, and install this package.  The following
 more-detailed instructions are generic; see the `README' file for
-instructions specific to this package.
+instructions specific to this package.  Some packages provide this
+`INSTALL' file but do not implement all of the features documented
+below.  The lack of an optional feature in a given package is not
+necessarily a bug.  More recommendations for GNU packages can be found
+in *note Makefile Conventions: (standards)Makefile Conventions.
 
    The `configure' shell script attempts to guess correct values for
 various system-dependent variables used during compilation.  It uses
@@ -42,7 +48,7 @@ may remove or edit it.
 you want to change it or regenerate `configure' using a newer version
 of `autoconf'.
 
-The simplest way to compile this package is:
+   The simplest way to compile this package is:
 
   1. `cd' to the directory containing the package's source code and type
      `./configure' to configure the package for your system.
@@ -53,12 +59,22 @@ The simplest way to compile this package is:
   2. Type `make' to compile the package.
 
   3. Optionally, type `make check' to run any self-tests that come with
-     the package.
+     the package, generally using the just-built uninstalled binaries.
 
   4. Type `make install' to install the programs and any data files and
-     documentation.
-
-  5. You can remove the program binaries and object files from the
+     documentation.  When installing into a prefix owned by root, it is
+     recommended that the package be configured and built as a regular
+     user, and only the `make install' phase executed with root
+     privileges.
+
+  5. Optionally, type `make installcheck' to repeat any self-tests, but
+     this time using the binaries in their final installed location.
+     This target does not install anything.  Running this target as a
+     regular user, particularly if the prior `make install' required
+     root privileges, verifies that the installation completed
+     correctly.
+
+  6. You can remove the program binaries and object files from the
      source code directory by typing `make clean'.  To also remove the
      files that `configure' created (so you can compile the package for
      a different kind of computer), type `make distclean'.  There is
@@ -67,12 +83,22 @@ The simplest way to compile this package is:
      all sorts of other programs in order to regenerate files that came
      with the distribution.
 
+  7. Often, you can also type `make uninstall' to remove the installed
+     files again.  In practice, not all packages have tested that
+     uninstallation works correctly, even though it is required by the
+     GNU Coding Standards.
+
+  8. Some packages, particularly those that use Automake, provide `make
+     distcheck', which can by used by developers to test that all other
+     targets like `make install' and `make uninstall' work correctly.
+     This target is generally not run by end users.
+
 Compilers and Options
 =====================
 
-Some systems require unusual options for compilation or linking that the
-`configure' script does not know about.  Run `./configure --help' for
-details on some of the pertinent environment variables.
+   Some systems require unusual options for compilation or linking that
+the `configure' script does not know about.  Run `./configure --help'
+for details on some of the pertinent environment variables.
 
    You can give `configure' initial values for configuration parameters
 by setting variables in the command line or in the environment.  Here
@@ -85,25 +111,41 @@ is an example:
 Compiling For Multiple Architectures
 ====================================
 
-You can compile the package for more than one kind of computer at the
+   You can compile the package for more than one kind of computer at the
 same time, by placing the object files for each architecture in their
 own directory.  To do this, you can use GNU `make'.  `cd' to the
 directory where you want the object files and executables to go and run
 the `configure' script.  `configure' automatically checks for the
-source code in the directory that `configure' is in and in `..'.
+source code in the directory that `configure' is in and in `..'.  This
+is known as a "VPATH" build.
 
    With a non-GNU `make', it is safer to compile the package for one
 architecture at a time in the source code directory.  After you have
 installed the package for one architecture, use `make distclean' before
 reconfiguring for another architecture.
 
+   On MacOS X 10.5 and later systems, you can create libraries and
+executables that work on multiple system types--known as "fat" or
+"universal" binaries--by specifying multiple `-arch' options to the
+compiler but only a single `-arch' option to the preprocessor.  Like
+this:
+
+     ./configure CC="gcc -arch i386 -arch x86_64 -arch ppc -arch ppc64" \
+                 CXX="g++ -arch i386 -arch x86_64 -arch ppc -arch ppc64" \
+                 CPP="gcc -E" CXXCPP="g++ -E"
+
+   This is not guaranteed to produce working output in all cases, you
+may have to build one architecture at a time and combine the results
+using the `lipo' tool if you have problems.
+
 Installation Names
 ==================
 
-By default, `make install' installs the package's commands under
+   By default, `make install' installs the package's commands under
 `/usr/local/bin', include files under `/usr/local/include', etc.  You
 can specify an installation prefix other than `/usr/local' by giving
-`configure' the option `--prefix=PREFIX'.
+`configure' the option `--prefix=PREFIX', where PREFIX must be an
+absolute file name.
 
    You can specify separate installation prefixes for
 architecture-specific files and architecture-independent files.  If you
@@ -114,16 +156,47 @@ Documentation and other data files still use the regular prefix.
    In addition, if you use an unusual directory layout you can give
 options like `--bindir=DIR' to specify different values for particular
 kinds of files.  Run `configure --help' for a list of the directories
-you can set and what kinds of files go in them.
+you can set and what kinds of files go in them.  In general, the
+default for these options is expressed in terms of `${prefix}', so that
+specifying just `--prefix' will affect all of the other directory
+specifications that were not explicitly provided.
+
+   The most portable way to affect installation locations is to pass the
+correct locations to `configure'; however, many packages provide one or
+both of the following shortcuts of passing variable assignments to the
+`make install' command line to change installation locations without
+having to reconfigure or recompile.
+
+   The first method involves providing an override variable for each
+affected directory.  For example, `make install
+prefix=/alternate/directory' will choose an alternate location for all
+directory configuration variables that were expressed in terms of
+`${prefix}'.  Any directories that were specified during `configure',
+but not in terms of `${prefix}', must each be overridden at install
+time for the entire installation to be relocated.  The approach of
+makefile variable overrides for each directory variable is required by
+the GNU Coding Standards, and ideally causes no recompilation.
+However, some platforms have known limitations with the semantics of
+shared libraries that end up requiring recompilation when using this
+method, particularly noticeable in packages that use GNU Libtool.
+
+   The second method involves providing the `DESTDIR' variable.  For
+example, `make install DESTDIR=/alternate/directory' will prepend
+`/alternate/directory' before all installation names.  The approach of
+`DESTDIR' overrides is not required by the GNU Coding Standards, and
+does not work on platforms that have drive letters.  On the other hand,
+it does better at avoiding recompilation issues, and works well even
+when some directory options were not specified in terms of `${prefix}'
+at `configure' time.
+
+Optional Features
+=================
 
    If the package supports it, you can cause programs to be installed
 with an extra prefix or suffix on their names by giving `configure' the
 option `--program-prefix=PREFIX' or `--program-suffix=SUFFIX'.
 
-Optional Features
-=================
-
-Some packages pay attention to `--enable-FEATURE' options to
+   Some packages pay attention to `--enable-FEATURE' options to
 `configure', where FEATURE indicates an optional part of the package.
 They may also pay attention to `--with-PACKAGE' options, where PACKAGE
 is something like `gnu-as' or `x' (for the X Window System).  The
@@ -135,14 +208,53 @@ find the X include and library files automatically, but if it doesn't,
 you can use the `configure' options `--x-includes=DIR' and
 `--x-libraries=DIR' to specify their locations.
 
+   Some packages offer the ability to configure how verbose the
+execution of `make' will be.  For these packages, running `./configure
+--enable-silent-rules' sets the default to minimal output, which can be
+overridden with `make V=1'; while running `./configure
+--disable-silent-rules' sets the default to verbose, which can be
+overridden with `make V=0'.
+
+Particular systems
+==================
+
+   On HP-UX, the default C compiler is not ANSI C compatible.  If GNU
+CC is not installed, it is recommended to use the following options in
+order to use an ANSI C compiler:
+
+     ./configure CC="cc -Ae -D_XOPEN_SOURCE=500"
+
+and if that doesn't work, install pre-built binaries of GCC for HP-UX.
+
+   On OSF/1 a.k.a. Tru64, some versions of the default C compiler cannot
+parse its `<wchar.h>' header file.  The option `-nodtk' can be used as
+a workaround.  If GNU CC is not installed, it is therefore recommended
+to try
+
+     ./configure CC="cc"
+
+and if that doesn't work, try
+
+     ./configure CC="cc -nodtk"
+
+   On Solaris, don't put `/usr/ucb' early in your `PATH'.  This
+directory contains several dysfunctional programs; working variants of
+these programs are available in `/usr/bin'.  So, if you need `/usr/ucb'
+in your `PATH', put it _after_ `/usr/bin'.
+
+   On Haiku, software installed for all users goes in `/boot/common',
+not `/usr/local'.  It is recommended to use the following options:
+
+     ./configure --prefix=/boot/common
+
 Specifying the System Type
 ==========================
 
-There may be some features `configure' cannot figure out automatically,
-but needs to determine by the type of machine the package will run on.
-Usually, assuming the package is built to be run on the _same_
-architectures, `configure' can figure that out, but if it prints a
-message saying it cannot guess the machine type, give it the
+   There may be some features `configure' cannot figure out
+automatically, but needs to determine by the type of machine the package
+will run on.  Usually, assuming the package is built to be run on the
+_same_ architectures, `configure' can figure that out, but if it prints
+a message saying it cannot guess the machine type, give it the
 `--build=TYPE' option.  TYPE can either be a short name for the system
 type, such as `sun4', or a canonical name which has the form:
 
@@ -150,7 +262,8 @@ type, such as `sun4', or a canonical name which has the form:
 
 where SYSTEM can have one of these forms:
 
-     OS KERNEL-OS
+     OS
+     KERNEL-OS
 
    See the file `config.sub' for the possible values of each field.  If
 `config.sub' isn't included in this package, then this package doesn't
@@ -168,9 +281,9 @@ eventually be run) with `--host=TYPE'.
 Sharing Defaults
 ================
 
-If you want to set default values for `configure' scripts to share, you
-can create a site shell script called `config.site' that gives default
-values for variables like `CC', `cache_file', and `prefix'.
+   If you want to set default values for `configure' scripts to share,
+you can create a site shell script called `config.site' that gives
+default values for variables like `CC', `cache_file', and `prefix'.
 `configure' looks for `PREFIX/share/config.site' if it exists, then
 `PREFIX/etc/config.site' if it exists.  Or, you can set the
 `CONFIG_SITE' environment variable to the location of the site script.
@@ -179,7 +292,7 @@ A warning: not all `configure' scripts look for a site script.
 Defining Variables
 ==================
 
-Variables not defined in a site shell script can be set in the
+   Variables not defined in a site shell script can be set in the
 environment passed to `configure'.  However, some packages may run
 configure again during the build, and the customized values of these
 variables may be lost.  In order to avoid this problem, you should set
@@ -198,11 +311,19 @@ an Autoconf bug.  Until the bug is fixed you can use this workaround:
 `configure' Invocation
 ======================
 
-`configure' recognizes the following options to control how it operates.
+   `configure' recognizes the following options to control how it
+operates.
 
 `--help'
 `-h'
-     Print a summary of the options to `configure', and exit.
+     Print a summary of all of the options to `configure', and exit.
+
+`--help=short'
+`--help=recursive'
+     Print a summary of the options unique to this package's
+     `configure', and exit.  The `short' variant lists options used
+     only in the top level, while the `recursive' variant lists options
+     also present in any nested packages.
 
 `--version'
 `-V'
@@ -229,6 +350,16 @@ an Autoconf bug.  Until the bug is fixed you can use this workaround:
      Look for the package's source code in directory DIR.  Usually
      `configure' can determine that directory automatically.
 
+`--prefix=DIR'
+     Use DIR as the installation prefix.  *note Installation Names::
+     for more details, including other options available for fine-tuning
+     the installation locations.
+
+`--no-create'
+`-n'
+     Run the configure checks, but stop before creating any output
+     files.
+
 `configure' also accepts some other, not widely useful, options.  Run
 `configure --help' for more details.
 
diff --git a/configure.ac b/configure.ac
index c42be91..0a8eb6d 100644
--- a/configure.ac
+++ b/configure.ac
@@ -51,6 +51,7 @@ AC_CHECK_FUNCS([gettimeofday memmove memset munmap select strcasecmp strchr strd
 
 # filters
 TSLIB_CHECK_MODULE([linear], [yes], [Enable building of linear scaling])
+TSLIB_CHECK_MODULE([linear_quad], [yes], [Enable building of linear quadrant scaling])
 TSLIB_CHECK_MODULE([dejitter], [yes], [Enable building of dejitter filter])
 TSLIB_CHECK_MODULE([linear-h2200], [yes], [Enable building of linearizing filter for iPAQ h2200])
 TSLIB_CHECK_MODULE([variance], [yes], [Enable building of variance filter])
diff --git a/etc/ts.conf b/etc/ts.conf
index dc5c4de..1465cdc 100644
--- a/etc/ts.conf
+++ b/etc/ts.conf
@@ -1,5 +1,5 @@
 # Uncomment if you wish to use the linux input layer event interface
-# module_raw input
+module_raw input
 
 # Uncomment if you're using a Sharp Zaurus SL-5500/SL-5000d
 # module_raw collie
@@ -22,4 +22,5 @@
 module pthres pmin=1
 module variance delta=30
 module dejitter delta=100
-module linear
+module linear_quad
+
diff --git a/plugins/Makefile.am b/plugins/Makefile.am
index a237e31..e9cb5f8 100644
--- a/plugins/Makefile.am
+++ b/plugins/Makefile.am
@@ -24,6 +24,12 @@ else
 LINEAR_MODULE =
 endif
 
+if ENABLE_LINEAR_QUAD_MODULE
+LINEAR_QUAD_MODULE = linear_quad.la
+else
+LINEAR_QUAD_MODULE =
+endif
+
 if ENABLE_LINEAR_MODULE
 DEJITTER_MODULE = dejitter.la
 else
@@ -116,6 +122,7 @@ endif
 
 pluginexec_LTLIBRARIES = \
 	$(LINEAR_MODULE) \
+	$(LINEAR_QUAD_MODULE) \
 	$(DEJITTER_MODULE) \
 	$(VARIANCE_MODULE) \
 	$(PTHRES_MODULE) \
@@ -144,6 +151,10 @@ linear_la_SOURCES	= linear.c
 linear_la_LDFLAGS	= -module $(LTVSN)
 linear_la_LIBADD	= $(top_builddir)/src/libts.la
 
+linear_quad_la_SOURCES	= linear_quad.c
+linear_quad_la_LDFLAGS	= -module $(LTVSN)
+linear_quad_la_LIBADD	= $(top_builddir)/src/libts.la
+
 pthres_la_SOURCES	= pthres.c
 pthres_la_LDFLAGS	= -module $(LTVSN)
 pthres_la_LIBADD	= $(top_builddir)/src/libts.la
diff --git a/plugins/input-raw.c b/plugins/input-raw.c
index 1e48505..c0a3355 100644
--- a/plugins/input-raw.c
+++ b/plugins/input-raw.c
@@ -69,7 +69,11 @@ struct tslib_input {
 #define BITS_PER_BYTE           8
 #define BITS_PER_LONG           (sizeof(long) * BITS_PER_BYTE)
 #define BITS_TO_LONGS(nr)       DIV_ROUND_UP(nr, BITS_PER_BYTE * sizeof(long))
+#ifndef EV_CNT
+#define EV_CNT	(EV_MAX+1)
+#endif
 
+int old_api = 0;
 static int check_fd(struct tslib_input *i)
 {
 	struct tsdev *ts = i->module.dev;
@@ -84,8 +88,28 @@ static int check_fd(struct tslib_input *i)
 	}
 
 	if (version < EV_VERSION) {
-		fprintf(stderr, "tslib: Selected device uses a different version of the event protocol than tslib was compiled for\n");
-		return -1;
+		unsigned long bit[EV_CNT / BITS_PER_LONG + 1];
+		unsigned long absbit[ABS_MAX / BITS_PER_LONG + 1];
+
+		if (version != 0x010000) {
+			fprintf(stderr, "tslib: Selected device uses a different version(%d) of the event protocol than tslib was compiled for(%d)\n",
+				version, EV_VERSION);
+			return -1;
+		}
+
+		if (! (	(ioctl(ts->fd, EVIOCGBIT(0, sizeof(bit)), bit) >= 0) &&
+			(bit[0] & (1 << EV_ABS)) &&
+			(ioctl(ts->fd, EVIOCGBIT(EV_ABS, sizeof(absbit)), absbit) >= 0) &&
+			(absbit[0] & (1 << ABS_X)) &&
+			(absbit[0] & (1 << ABS_Y)) && (absbit[0] & (1 << ABS_PRESSURE)))) {
+			fprintf(stderr, "selected device is not a touchscreen I understand\n");
+			return -1;
+		}
+
+		if (bit[0] & (1 << EV_SYN))
+			i->using_syn = 1;
+		old_api = 1;
+		return 0;
 	}
 
 	if ( (ioctl(ts->fd, EVIOCGBIT(0, sizeof(evbit)), evbit) < 0) ||
diff --git a/plugins/linear_quad.c b/plugins/linear_quad.c
new file mode 100644
index 0000000..799aeb3
--- /dev/null
+++ b/plugins/linear_quad.c
@@ -0,0 +1,369 @@
+/*
+ *  tslib/plugins/linear.c
+ *
+ *  Copyright (C) 2001 Russell King.
+ *
+ * This file is placed under the LGPL.  Please see the file
+ * COPYING for more details.
+ *
+ * $Id: linear.c,v 1.10 2005/02/26 01:47:23 kergoth Exp $
+ *
+ * Linearly scale touchscreen values
+ */
+#include <stdlib.h>
+#include <string.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#include <fcntl.h>
+
+#include <stdio.h>
+#include <linux/input.h>
+
+#include "tslib.h"
+#include "tslib-filter.h"
+#include "tsquadrant_cal.h"
+#include "tslib-private.h"
+
+struct tslib_linear {
+	struct tslib_module_info module;
+
+// Linear scaling and offset parameters for x,y (can include rotation)
+	struct cal_result res[5];
+	int xMax;
+	int yMax;
+	int iMax;
+	int jMax;
+	int ncoeffs;
+	int nregions;
+};
+
+static void transform(struct tslib_linear *lin, struct ts_sample *samp)
+{
+	int x, y, cx, cy;
+	int xMax = lin->xMax;
+	int yMax = lin->yMax;
+	int q = QUAD_MAIN;
+
+#ifdef DEBUG
+	fprintf(stderr,"BEFORE CALIB--------------------> %d %d %d\n",samp->x, samp->y, samp->pressure);
+#endif /*DEBUG*/
+	for (;;) {
+		long long int t1, t2;
+		struct cal_result *r = &lin->res[q];
+		x = samp->x;
+		y = samp->y;
+		t1 = r->a[0];
+		t1 *= x;
+		t2 = r->a[1];
+		t2 *= y;
+		cx = (int)(t1 + t2 + r->a[2]);
+#ifdef DEBUG
+		printf("t1 %x %x, t2 %x %x, a0 %x, a1 %x, a2 %x, shift %d\n",
+				(unsigned)(t1 >> 32), (unsigned)t1,
+				(unsigned)(t2 >> 32), (unsigned)t2,
+				r->a[0], r->a[1], r->a[2], r->shift);
+#endif
+		t1 = r->a[3];
+		t1 *= x;
+		t2 = r->a[4];
+		t2 *= y;
+		cy = (int)((t1 + t2 + r->a[5]));
+		if (r->shift < 0) {
+			cx >>= -r->shift;
+			cy >>= -r->shift;
+		} else {
+			cx <<= r->shift;
+			cy <<= r->shift;
+		}
+		if (cx < 0)
+			cx = 0;
+		if (cy < 0)
+			cy = 0;
+		if (!xMax || !yMax)
+			break;
+		if (cx >= xMax)
+			cx = xMax - 1;
+		if (cy >= yMax)
+			cy = yMax - 1;
+		if (q != QUAD_MAIN)
+			break;
+		if (cx) {
+			int yMaxCx = yMax * cx;
+			int xMaxCy = xMax * cy;
+			int xMaxRevCy = (yMax - cy) * xMax;
+			/* if (cy/cx >= yMax/xMax) */
+			if (xMaxCy >= yMaxCx) {
+				/* if ((yMax - cy)/cx >= yMax/xMax) */
+				q = (xMaxRevCy >= yMaxCx) ? QUAD_LEFT : QUAD_BOTTOM;
+			} else {
+				q = (xMaxRevCy >= yMaxCx) ? QUAD_TOP : QUAD_RIGHT;
+			}
+		} else {
+			q = QUAD_LEFT;
+		}
+	}
+	samp->x = cx;
+	samp->y = cy;
+#ifdef DEBUG
+	printf("%s: %d,%d\n", __func__, cx, cy);
+#endif
+}
+
+static void transform6(struct tslib_linear *lin, struct ts_sample *samp)
+{
+	u32 s[6];
+	s64 xsum, ysum;
+	s32 cx, cy;
+	int xMax = lin->xMax;
+	int yMax = lin->yMax;
+	struct cal_result *r = &lin->res[0];
+	int i;
+
+#ifdef DEBUG
+	fprintf(stderr,"BEFORE CALIB--------------------> %d %d %d\n",samp->x, samp->y, samp->pressure);
+#endif /*DEBUG*/
+
+	cx = samp->x;
+	cy = samp->y;
+	if ((cx >= lin->iMax) || (cy >= lin->jMax))
+		printf("!!!%s:i=%d imax=%d, j=%d jmax=%d\n", __func__,
+				cx, lin->iMax, cy, lin->jMax);
+	s[0] = 1 << 16;
+	s[1] = (cx << 16) / lin->iMax;
+	s[2] = (cy << 16) / lin->jMax;
+	s[3] = (s[1] * s[2]) >> 16;
+	s[4] = (s[1] * s[1]) >> 16;
+	s[5] = (s[2] * s[2]) >> 16;
+
+	xsum = 0;
+	ysum = 0;
+	for (i = 0; i < 6 ; i++) {
+		xsum += (r->a[i] * (s64)s[i]);
+		ysum += (r->a[i + 6] * (s64)s[i]);
+	}
+	cx = (s32)((xsum * xMax) >> 32);
+	cy = (s32)((ysum * yMax) >> 32);
+	if (cx < 0)
+		cx = 0;
+	if (cy < 0)
+		cy = 0;
+	if (cx >= xMax)
+		cx = xMax - 1;
+	if (cy >= yMax)
+		cy = yMax - 1;
+	samp->x = cx;
+	samp->y = cy;
+#ifdef DEBUG
+	printf("%s: %d,%d\n", __func__, cx, cy);
+#endif
+}
+
+static int
+linearq_read(struct tslib_module_info *info, struct ts_sample *samp, int nr)
+{
+	struct tslib_linear *lin = (struct tslib_linear *)info;
+	int ret;
+
+	ret = info->next->ops->read(info->next, samp, nr);
+	if (ret >= 0) {
+		int nr;
+		for (nr = 0; nr < ret; nr++, samp++) {
+			if (lin->xMax && lin->nregions == 1)
+				transform6(lin, samp);
+			else
+				transform(lin, samp);
+		}
+	}
+	return ret;
+}
+
+static int linearq_fini(struct tslib_module_info *info)
+{
+	free(info);
+	return 0;
+}
+
+static const struct tslib_ops linear_ops =
+{
+	.read	= linearq_read,
+	.fini	= linearq_fini,
+};
+
+const char *past_delim(const char* p, const char* delim, int count)
+{
+	for (;;) {
+		char c = p[0];
+		int i = 0;
+		if (!c)
+			return p;
+		for (;;) {
+			if (c == delim[i])
+				break;
+			i++;
+			if (i >= count)
+				return p;
+		}
+		p++;
+	}
+}
+
+const char delim_array[] = { ' ', 0x09, 0x0d, 0x0a, '(', ')', ','};
+
+int get_linear_settings(struct tslib_linear *lin, char *p)
+{
+	int cal[6];
+	int index;
+	for (index = 0; index < 6; index++) {
+		char *pend;
+		p = (char *)past_delim(p, delim_array, sizeof(delim_array));
+		if (!*p) {
+			printf("Error, not enough numbers\n");
+			return -1;
+		}
+		cal[index] = strtol(p, &pend, 10);
+		p = pend;
+	}
+	for (index = 0; index < 6; index++)
+		lin->res[QUAD_MAIN].a[index] = cal[index];
+	lin->res[QUAD_MAIN].shift = -16;
+	lin->xMax = 0;
+	lin->yMax = 0;
+#ifdef DEBUG
+	printf("Linear calibration constants: ");
+	for(index=0;index<7;index++) printf("%d ",lin->res[QUAD_MAIN].a[index]);
+	printf("\n");
+#endif /*DEBUG*/
+	return 0;
+}
+
+int get_linearq_settings(struct tslib_linear *lin, char *p)
+{
+	int q;
+	int r;
+	struct cal_data cal[9];
+	for (q = 0; q < 9; q++) {
+		int index;
+		for (index = 0; index < 4; index++) {
+			char *pend;
+			p = (char *)past_delim(p, delim_array, sizeof(delim_array));
+			if (!*p) {
+				printf("Error, not enough numbers (%d, %d)\n", q, index);
+				return -1;
+			}
+			(&cal[q].x)[index] = strtol(p, &pend, 10);
+			p = pend;
+		}
+		p = (char *)past_delim(p, delim_array, sizeof(delim_array));
+		if (!*p)
+			break;
+	}
+	if (q < 3) {
+		printf("Error, not enough points (%d)\n", q);
+		return -1;
+	}
+	lin->ncoeffs = 12;
+	lin->nregions = 1;
+
+	lin->xMax = cal[PT_MM].x * 2;
+	lin->yMax = cal[PT_MM].y * 2;
+	r = perform_n_point_calibration(cal, q, lin->xMax, lin->yMax,
+				lin->iMax, lin->jMax, lin->res);
+#ifdef DEBUG
+	printf("xMax=%d yMax=%d\n", lin->xMax, lin->yMax);
+	printf("Linear calibration constants: ");
+	for (q = 0; q < lin->nregions; q++) {
+		int index;
+		for(index = 0; index < lin->ncoeffs; index++)
+			printf("%d ",lin->res[q].a[index]);
+		printf("shift %d\n",lin->res[q].shift);
+	}
+#endif /*DEBUG*/
+	return r;
+}
+
+TSAPI struct tslib_module_info *linear_quad_mod_init(struct tsdev *ts, const char *params)
+{
+
+	struct tslib_linear *lin;
+	struct stat sbuf;
+	int pcal_fd;
+	char inputbuf[400];
+	int q;
+	int r;
+	char *calfile=NULL;
+	struct input_absinfo abs;
+
+	lin = malloc(sizeof(struct tslib_linear));
+	if (lin == NULL)
+		return NULL;
+
+	lin->module.ops = &linear_ops;
+	lin->iMax = 2048;
+	lin->jMax = 2048;
+
+// Use default values that leave ts numbers unchanged after transform
+	for (q = 0; q < 5; q++) {
+		lin->res[q].a[0] = 1;
+		lin->res[q].a[1] = 0;
+		lin->res[q].a[2] = 0;
+		lin->res[q].a[3] = 0;
+		lin->res[q].a[4] = 1;
+		lin->res[q].a[5] = 0;
+		lin->res[q].shift = 0;
+	}
+	lin->xMax = lin->yMax = 0;
+
+
+	if (ioctl(ts->fd, EVIOCGABS(0), &abs) == 0) {
+		lin->iMax = abs.maximum + 1;
+		printf("iMax = %d\n", lin->iMax);
+	} else {
+		printf("iMax read error, defaulting to 2048\n");
+	}
+	if (ioctl(ts->fd, EVIOCGABS(1), &abs) == 0) {
+		lin->jMax = abs.maximum + 1;
+		printf("jMax = %d\n", lin->jMax);
+	} else {
+		printf("jMax read error, defaulting to 2048\n");
+	}
+	/*
+	 * Check calibration file
+	 */
+	calfile = getenv("TSLIB_CALIBFILE");
+	if (!calfile)
+		calfile = TS_POINTERCAL;
+	if (stat(calfile, &sbuf)==0) {
+		char *p = inputbuf;
+		int size;
+		pcal_fd = open(calfile,O_RDONLY);
+		size = read(pcal_fd,p,sizeof(inputbuf) - 1);
+		if ((unsigned)size >= sizeof(inputbuf)) {
+			printf("read returned %d\n", size);
+			goto err1;
+		}
+		p[size] = 0;
+
+		if (p[0] != '(') {
+			/* ts_calibrate was used instead of ts_calibrate_quadrant */
+			printf("Warning: use ts_calibrate_quadrant to get benefit of this module\n");
+			r = get_linear_settings(lin, p);
+		} else {
+			r = get_linearq_settings(lin, p);
+		}
+		if (r < 0) {
+			printf("calibration error %d\n", r);
+			goto err1;
+		}
+		close(pcal_fd);
+	}
+	return &lin->module;
+err1:
+	close(pcal_fd);
+	free(lin);
+	return NULL;
+}
+
+#ifndef TSLIB_STATIC_LINEAR_QUAD_MODULE
+	TSLIB_MODULE_INIT(linear_quad_mod_init);
+#endif
diff --git a/src/Makefile.am b/src/Makefile.am
index 5278d82..49700d3 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -12,12 +12,12 @@ AM_CFLAGS	 = -DPLUGIN_DIR=\"@PLUGIN_DIR@\" -DTS_CONF=\"@TS_CONF@\" -DTS_POINTERC
 		   $(DEBUGFLAGS) $(LIBFLAGS) $(VIS_CFLAGS)
 
 noinst_HEADERS   = tslib-private.h tslib-filter.h
-include_HEADERS  = tslib.h
+include_HEADERS  = tslib.h tsquadrant_cal.h
 
 lib_LTLIBRARIES  = libts.la
 libts_la_SOURCES = ts_attach.c ts_close.c ts_config.c ts_error.c \
 		   ts_fd.c ts_load_module.c ts_open.c ts_parse_vars.c \
-		   ts_read.c ts_read_raw.c ts_option.c
+		   ts_read.c ts_read_raw.c ts_option.c tsquadrant_cal.c
 
 if ENABLE_STATIC_LINEAR_MODULE
 libts_la_SOURCES += $(top_srcdir)/plugins/linear.c
diff --git a/src/ts_open.c b/src/ts_open.c
index d38babf..dbc2b46 100644
--- a/src/ts_open.c
+++ b/src/ts_open.c
@@ -17,12 +17,16 @@
 #include <unistd.h>
 #endif
 #include <sys/fcntl.h>
+#include <stdio.h>
+#include <linux/fb.h>
+#include <linux/input.h>
 
 #include "tslib-private.h"
+#define ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]))
 
 extern struct tslib_module_info __ts_raw;
 
-struct tsdev *ts_open(const char *name, int nonblock)
+static struct tsdev *ts_open_xy(const char *name, int nonblock, int xres, int yres)
 {
 	struct tsdev *ts;
 	int flags = O_RDWR;
@@ -33,6 +37,8 @@ struct tsdev *ts_open(const char *name, int nonblock)
 	ts = malloc(sizeof(struct tsdev));
 	if (ts) {
 		memset(ts, 0, sizeof(struct tsdev));
+		ts->xres = xres;
+		ts->yres = yres;
 
 		ts->fd = open(name, flags);
 		/*
@@ -47,9 +53,143 @@ struct tsdev *ts_open(const char *name, int nonblock)
 			goto free;
 	}
 
+	printf("%s:%s:screen resolution = %dx%d\n", __func__, name, ts->xres, ts->yres);
 	return ts;
 
 free:
 	free(ts);
 	return NULL;
 }
+
+static const char * const input_choices[] = {"/dev/input/ts",
+	"/dev/input/event0", "/dev/input/event1",
+	"/dev/input/event2", "/dev/touchscreen/ucb1x00",
+};
+
+#define DIV_ROUND_UP(n,d) (((n) + (d) - 1) / (d))
+#define BIT(nr)                 (1UL << (nr))
+#define BIT_MASK(nr)            (1UL << ((nr) % BITS_PER_LONG))
+#define BIT_WORD(nr)            ((nr) / BITS_PER_LONG)
+#define BITS_PER_BYTE           8
+#define BITS_PER_LONG           (sizeof(long) * BITS_PER_BYTE)
+#define BITS_TO_LONGS(nr)       DIV_ROUND_UP(nr, BITS_PER_BYTE * sizeof(long))
+#ifndef EV_CNT
+#define EV_CNT	(EV_MAX+1)
+#endif
+
+static int is_touchscreen(struct tsdev *ts)
+{
+	int ret;
+	long evbit[BITS_TO_LONGS(EV_CNT)];
+	long absbit[BITS_TO_LONGS(ABS_CNT)];
+
+	ret = ioctl(ts->fd, EVIOCGBIT(0, sizeof(evbit)), evbit);
+	if ( (ret < 0) || !(evbit[BIT_WORD(EV_ABS)] & BIT_MASK(EV_ABS)) ||
+		!(evbit[BIT_WORD(EV_KEY)] & BIT_MASK(EV_KEY)) ) {
+		return 0;
+	}
+
+	ret = ioctl(ts->fd, EVIOCGBIT(EV_ABS, sizeof(absbit)), absbit);
+	if ( (ret < 0) || !(absbit[BIT_WORD(ABS_X)] & BIT_MASK(ABS_X)) ||
+		!(absbit[BIT_WORD(ABS_Y)] & BIT_MASK(ABS_Y))) {
+		return 0;
+	}
+	return 1;
+}
+
+struct tsdev *ts_try_dev(const char *p, int nonblock, int xres, int yres)
+{
+	struct tsdev *ts;
+
+	if (!p)
+		return NULL;
+
+	ts = ts_open_xy(p, nonblock, xres, yres);
+	if (!ts)
+		return ts;
+	if (is_touchscreen(ts))
+		return ts;
+	ts_close(ts);
+	return NULL;
+}
+
+struct tsdev *ts_try_open(int nonblock, int xres, int yres, int index, const char **pp)
+{
+	const char *p = NULL;
+
+	if (index == -1) {
+		p = getenv("TSLIB_TSDEVICE");
+	} else if (index < (int)ARRAY_SIZE(input_choices)) {
+		p = input_choices[index];
+	}
+	*pp = p;
+	return ts_try_dev(p, nonblock, xres, yres);
+}
+
+struct tsdev *ts_open_config(int nonblock, int xres, int yres)
+{
+	struct tsdev *ts;
+	const char *p;
+	int i;
+
+	for (i = -1; i < (int)ARRAY_SIZE(input_choices); i++) {
+		ts = ts_try_open(nonblock, xres, yres, i, &p);
+		if (ts) {
+			if (!ts_config(ts)) {
+				printf("opened:%s\n", p);
+				return ts;
+			}
+			perror("ts_config");
+			ts_close(ts);
+		}
+	}
+	return NULL;
+}
+
+static char *defaultfbdevice = "/dev/fb0";
+
+struct tsdev *ts_open(const char *name, int nonblock)
+{
+	struct fb_var_screeninfo var;
+	struct tsdev *ts;
+	char *fbdevice;
+	const char *p;
+	int fb;
+	int xres = 0;
+	int yres = 0;
+	int i;
+
+	fbdevice = getenv("TSLIB_FBDEVICE");
+	if (!fbdevice)
+		fbdevice = defaultfbdevice;
+
+	fb = open(fbdevice, O_RDWR);
+	if (fb == -1) {
+		perror("open fbdevice");
+		goto c1;
+	}
+
+	if (ioctl(fb, FBIOGET_VSCREENINFO, &var) < 0) {
+		perror("ioctl FBIOGET_VSCREENINFO");
+		goto c1;
+	}
+
+	xres = var.xres;
+	yres = var.yres;
+c1:
+	close(fb);
+
+	ts = ts_try_dev(name, nonblock, xres, yres);
+	if (ts) {
+		printf("opened:%s\n", p);
+		return ts;
+	}
+	for (i = -1; i < (int)ARRAY_SIZE(input_choices); i++) {
+		ts = ts_try_open(nonblock, xres, yres, i, &p);
+		if (ts) {
+			printf("opened:%s\n", p);
+			return ts;
+		}
+	}
+	return NULL;
+}
diff --git a/src/tslib-private.h b/src/tslib-private.h
index bffc62e..250afcb 100644
--- a/src/tslib-private.h
+++ b/src/tslib-private.h
@@ -23,6 +23,8 @@ struct tsdev {
 	struct tslib_module_info *list_raw; /* points to position in 'list' where raw reads
 					       come from.  default is the position of the
 					       ts_read_raw module. */
+	unsigned xres;
+	unsigned yres;
 	unsigned int res_x;
 	unsigned int res_y;
 	int rotation;
diff --git a/src/tslib.h b/src/tslib.h
index df8e284..d6b76f2 100644
--- a/src/tslib.h
+++ b/src/tslib.h
@@ -85,6 +85,7 @@ TSAPI int ts_load_module(struct tsdev *, const char *mod, const char *params);
  * Open the touchscreen device.
  */
 TSAPI struct tsdev *ts_open(const char *dev_name, int nonblock);
+TSAPI struct tsdev *ts_open_config(int nonblock, int xres, int yres);
 
 /*
  * Return a scaled touchscreen sample.
diff --git a/src/tsquadrant_cal.c b/src/tsquadrant_cal.c
new file mode 100644
index 0000000..890ff37
--- /dev/null
+++ b/src/tsquadrant_cal.c
@@ -0,0 +1,1009 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <strings.h>
+#include <string.h>
+#include "tsquadrant_cal.h"
+#define DEBUG
+/*
+let i,j be numbers between 0 and <1 (touchscreen reading/max res)
+let x,y be numbers between 0 and <1 (screen pos/max screen dimension)
+
+x = a1 + a2*i + a3*j + a4*i*j + a5*i*i + a6*j*j
+
+|x| = |a1 a2 a3 a4 a5 a6| | 1   |
+|y|   |b1 b2 b3 b4 b5 b6| | i   |
+			  | j   |
+			  | i*j |
+			  | i*i |
+			  | j*j |
+
+
+| x1  x2  x3 x4 x5 x6|  =  | a1  a2  a3  a4 a5 a6| | 1      1       1      1      1      1    |
+| y1  y2  y3 y4 y5 y6|     | b1  b2  b3  b4 b5 b6| | i1     i2      i3     i4     i5     i6   |
+						   | j1     j2      j3     j4     j5     j6   |
+						   | i1*j1  i2*j2   i3*j3  i4*j4  i5*j5  i6*j6|
+						   | i1*i1  i2*i2   i3*i3  i4*i4  i5*i5  i6*i6|
+						   | j1*j1  j2*j2   j3*j3  j4*j4  j5*j5  j6*j6|
+
+For multiple points, _ means summation
+| _x _xi _xj  _xij _xi2 _xj2| = | a1 a2 a3 a4 a5 a6|	| n    _i      _j     _ij    _i2    _j2  |
+| _y _yi _yj  _yij _yi2 _yj2|   | b1 b2 b3 b4 b5 b6|	|_i    _i2     _ij    _i2j   _i3    _ij2 |
+							|_j    _ij     _j2    _ij2   _i2j   _j3  |
+							|_ij   _i2j    _ij2   _i2j2  _i3j   _ij3 |
+							|_i2   _i3     _i2j   _i3j   _i4    _i2j2|
+							|_j2   _ij2    _j3    _ij3   _i2j2  _j4  |
+
+
+Numbers by i or j mean ** (squared or cubed or 4th power)
+
+| _x _xi _xj  _xij _xi2 _xj2|	| n    _i     _j    _ij    _i2    _j2  | -1 = | a1 a2 a3 a4 a5 a6 |
+| _y _yi _yj  _yij _yi2 _yj2|	|_i    _i2    _ij   _i2j   _i3    _ij2 |      | b1 b2 b3 b4 b5 b6 |
+				|_j    _ij    _j2   _ij2   _i2j   _j3  |
+				|_ij   _i2j   _ij2  _i2j2  _i3j   _ij3 |
+				|_i2   _i3    _i2j  _i3j   _i4    _i2j2|
+				|_j2   _ij2   _j3   _ij3   _i2j2  _j4  |
+(A)-1 = 1/det(A) * adj(A)
+adj(A)ij = (-1)**(i+j) det(minor_ji(A))
+ */
+#define utype long double
+#define stype long double
+#define DFORMAT "%20.10Lf"
+#define FIXED_FORMAT "%20.10Lf"
+
+/* Symmetrical matrix, only half filled in */
+static utype get_element(utype *s, unsigned row, unsigned col)
+{
+	if (row <= col)
+		return s[row * 6 + col];
+	return s[col * 6 + row];
+}
+
+/* Symmetrical matrix, only half filled in */
+static stype get_adj_element(stype *d, unsigned row, unsigned col)
+{
+	if (row <= col)
+		return d[row * 6 + col];
+	return d[col * 6 + row];
+}
+
+static stype mull(stype m, utype e)
+{
+	return m * e;
+}
+
+static stype determinate(utype *s, unsigned row_mask, unsigned col_mask)
+{
+	unsigned col = ffs(col_mask) - 1;
+	unsigned row = ffs(row_mask) - 1;
+	stype det = 0;
+	int neg = 0;
+	unsigned r_mask = row_mask & ~(1 << row);
+
+	if (!r_mask)
+		return get_element(s, row, col);
+
+	while (col < 6) {
+		if (col_mask & (1 << col)) {
+			unsigned c_mask = col_mask & ~(1 << col);
+			stype m = determinate(s, r_mask, c_mask);
+			utype e = get_element(s, row, col);
+
+#ifdef DEBUG
+//			printf("%s: m = " DFORMAT " e= " DFORMAT "\n", __func__, m, e);
+#endif
+			m = mull(m, e);
+			if (neg)
+				m = -m;
+			det += m;
+			neg ^= 1;
+		}
+		col++;
+	}
+#ifdef DEBUG
+//	printf("%s: det = " DFORMAT "\n", __func__, det);
+#endif
+	return det;
+}
+
+utype cval(u32 n) {
+	return (utype)n;
+}
+
+utype mval(utype a, utype b) {
+	return a * b;
+}
+
+TSAPI extern int perform_n_point_calibration(struct cal_data *cal,
+		int num_points, u32 xmax, u32 ymax, u32 imax, u32 jmax,
+		struct cal_result *res)
+{
+	s32 a[2][6];
+	utype r[2][6];
+	utype s[6 * 6];
+	stype d[6 * 6];
+	unsigned row;
+	unsigned col;
+	stype det;
+	int p;
+	unsigned mask = 0x3f;
+
+	printf("xmax=%d, ymax=%d imax=%d, jmax=%d\n", xmax, ymax, imax, jmax);
+
+	memset(a, 0, sizeof(a));
+	memset(r, 0, sizeof(r));
+	memset(s, 0, sizeof(s));
+
+	s[0 * 6 + 0] = cval(num_points);
+
+	for (p = 0; p < num_points; p++) {
+		struct cal_data *d = &cal[p];
+		utype x = cval(d->x) / xmax;
+		utype y = cval(d->y) / ymax;
+		utype i = cval(d->i) / imax;
+		utype j = cval(d->j) / jmax;
+		utype ij = mval(i, j);
+		utype i2 = mval(i, i);
+		utype j2 = mval(j, j);
+
+		r[0][0] += x;
+		r[0][1] += mval(x, i);
+		r[0][2] += mval(x, j);
+		r[0][3] += mval(x, ij);
+		r[0][4] += mval(x, i2);
+		r[0][5] += mval(x, j2);
+
+		r[1][0] += y;
+		r[1][1] += mval(y, i);
+		r[1][2] += mval(y, j);
+		r[1][3] += mval(y, ij);
+		r[1][4] += mval(y, i2);
+		r[1][5] += mval(y, j2);
+/*		   0     1     2     3      4      5
+		0| n    _i     _j    _ij    _i2    _j2  |
+		1|_i    _i2    _ij   _i2j   _i3    _ij2 |
+		2|_j    _ij    _j2   _ij2   _i2j   _j3  |
+		3|_ij   _i2j   _ij2  _i2j2  _i3j   _ij3 |
+		4|_i2   _i3    _i2j  _i3j   _i4    _i2j2|
+		5|_j2   _ij2   _j3   _ij3   _i2j2  _j4  |
+*/
+
+		s[0 * 6 + 1] += i;
+		s[1 * 6 + 1] += i2;
+
+		s[0 * 6 + 2] += j;
+		s[1 * 6 + 2] += ij;
+		s[2 * 6 + 2] += j2;
+
+		s[1 * 6 + 3] += mval(i, ij);	/* i2j */
+		s[2 * 6 + 3] += mval(j, ij);	/* ij2 */
+		s[3 * 6 + 3] += mval(ij, ij);	/* i2j2 */
+
+		s[1 * 6 + 4] += mval(i, i2);	/* i3 */
+		s[3 * 6 + 4] += mval(ij, i2);	/* i3j */
+		s[4 * 6 + 4] += mval(i2, i2);	/* i4 */
+
+		s[2 * 6 + 5] += mval(j, j2);	/* j3 */
+		s[3 * 6 + 5] += mval(ij, j2);	/* ij3 */
+		s[5 * 6 + 5] += mval(j2, j2);	/* j4 */
+	}
+	s[0 * 6 + 3] = s[1 * 6 + 2];	/* ij */
+
+	s[0 * 6 + 4] = s[1 * 6 + 1];	/* i2 */
+	s[2 * 6 + 4] = s[1 * 6 + 3];	/* i2j */
+
+	s[0 * 6 + 5] = s[2 * 6 + 2];	/* j2 */
+	s[1 * 6 + 5] = s[2 * 6 + 3];	/* ij2 */
+	s[4 * 6 + 5] = s[3 * 6 + 3];	/* i2j2 */
+
+	if (num_points < 6)
+		mask &= 0x7;
+
+	det = determinate(s, mask, mask);
+	if ((det > -.000000001) && (det < .000000001)) {
+		printf("ts_calibrate: determinant is " DFORMAT "\n", det);
+		return -1;
+	}
+#ifdef DEBUG
+	printf("input: det = " DFORMAT "\n", det);
+
+	for (row = 0; row < 6; row++) {
+		if (mask & (1 << row)) {
+			for (col = 0; col <= row; col++) {
+				if (mask & (1 << col)) {
+					printf(FIXED_FORMAT " ", get_element(s, row, col));
+				}
+			}
+			printf("\n");
+		}
+	}
+#endif
+
+	/* calculate inverse of matrix s */
+	for (row = 0; row < 6; row++) {
+		if (mask & (1 << row)) {
+			int neg = 0;
+			for (col = row; col < 6; col++) {
+				if (mask & (1 << col)) {
+					stype det1 = determinate(s, mask ^ (1 << row), mask ^(1 << col));
+
+					if (neg)
+						det1 = -det1;
+					d[row * 6 + col] = det1;
+					neg ^= 1;
+				}
+			}
+		}
+	}
+
+#ifdef DEBUG
+	printf("Adj\n");
+	for (row = 0; row < 6; row++) {
+		if (mask & (1 << row)) {
+			for (col = 0; col <= row; col++) {
+				if (mask & (1 << col)) {
+					printf(FIXED_FORMAT " ", get_adj_element(d, row, col));
+				}
+			}
+			printf("\n");
+		}
+	}
+#endif
+
+	for (row = 0; row < 2; row ++) {
+		for (col = 0; col < 6; col++) {
+			if (mask & (1 << col)) {
+				stype sum = 0;
+				int w;
+				for (w = 0; w < 6; w++) {
+					if (mask & (1 << w))
+						sum += mull(get_adj_element(d, w, col), r[row][w]);
+				}
+				sum /= det;
+				a[row][col] = (int)(sum * 65536);
+#ifdef DEBUG
+				printf("a=%d (" DFORMAT ")\n", a[row][col], sum);
+#endif
+			}
+		}
+	}
+	res->a[0] = a[0][0];
+	res->a[1] = a[0][1];
+	res->a[2] = a[0][2];
+	res->a[3] = a[0][3];
+	res->a[4] = a[0][4];
+	res->a[5] = a[0][5];
+	res->a[6] = a[1][0];
+	res->a[7] = a[1][1];
+	res->a[8] = a[1][2];
+	res->a[9] = a[1][3];
+	res->a[10] = a[1][4];
+	res->a[11] = a[1][5];
+	res->shift = 16;
+	printf("x: %d, %d i, %d j, %d ij, %d i2, %d j2\n", a[0][0], a[0][1], a[0][2], a[0][3], a[0][4], a[0][5]);
+	printf("y: %d, %d i, %d j, %d ij, %d i2, %d j2\n", a[1][0], a[1][1], a[1][2], a[1][3], a[1][4], a[1][5]);
+	return 0;
+}
+
+#define DEBUG
+
+#if 1
+typedef double sxx_t;
+typedef double uxx_t;
+#define UXDECL(name, n) uxx_t name
+#define SXDECL(name, n) sxx_t name
+#define xx_neg(s) s = -s;
+#define xx_reciprocal(s, b, tmp) s = 1/b;
+#define xx_uset(s, n) s = n;
+#define xx_cmp(s, n) ((s == n) ? 0 : (s < n) ? -1 : 1)
+#define xx_uadd2(s, b) s += b
+#define xx_usub2(s, b) s -= b
+#define xx_umul_sum(s, a, b) s += a * b
+#define xx_sumul_sum(s, a, b) s += a * b
+#define xx_sumul(s, a, b) s = a * b
+#define xx_umul(s, a, b) s = a * b
+#define xx_usub3(s, a, b) s = a - b
+#define xx_get_val(s, pshift, tmp)	_xx_get_val(s, pshift)
+int _xx_get_val(sxx_t s, int *pshift)
+{
+	int sign = 1;
+	int shift = 0;
+	if (s < 0) {
+		sign = -1;
+		s = -s;
+	}
+	while (s >= (unsigned)0x80000000) {
+		s = s / 2;
+		shift++;
+	}
+	while (s < 0x40000000) {
+		s = s * 2;
+		shift--;
+	}
+	*pshift = shift;
+	if (sign < 0)
+		s = -s;
+	return (int)s;
+}
+
+#else
+#if 1
+typedef unsigned sxx_t;
+typedef unsigned uxx_t;
+typedef unsigned long long udxx_t;
+#else
+/* For debugging code */
+typedef unsigned char sxx_t;
+typedef unsigned char uxx_t;
+typedef unsigned short udxx_t;
+#endif
+
+#define XX_GROUP (sizeof(uxx_t) * 8)
+#define XUNIT (32 / XX_GROUP)
+#define UXDECL(name, n) uxx_t name[n*XUNIT]
+#define SXDECL(name, n) sxx_t name[n*XUNIT]
+
+#define ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]))
+#define xx_neg(s)		_xx_usub3(s, ARRAY_SIZE(s), 0, 0, b, ARRAY_SIZE(b))
+#define xx_reciprocal(s, b, rem) _xx_reciprocal(s, ARRAY_SIZE(s), b, ARRAY_SIZE(b), rem, ARRAY_SIZE(rem))
+#define xx_get_val(s, pshift, shr)	_xx_get_val(s, ARRAY_SIZE(s), pshift, shr)
+#define xx_uset(s, n)		_xx_uset(s, ARRAY_SIZE(s), n)
+#define xx_cmp(s, n)		_xx_cmp(s, ARRAY_SIZE(s), n)
+#define xx_uadd2(s, b)		_xx_uadd2(s, ARRAY_SIZE(s), b, ARRAY_SIZE(b))
+#define xx_usub2(s, b)		_xx_usub2(s, ARRAY_SIZE(s), b, ARRAY_SIZE(b))
+#define xx_umul_sum(s, a, b)	_xx_umul_sum(s, ARRAY_SIZE(s), a, ARRAY_SIZE(a), b, ARRAY_SIZE(b))
+#define xx_sumul_sum(s, a, b)	_xx_sumul_sum(s, ARRAY_SIZE(s), a, ARRAY_SIZE(a), b, ARRAY_SIZE(b))
+#define xx_umul(s, a, b)	xx_uset(s, 0); xx_umul_sum(s, a, b)
+#define xx_sumul(s, a, b)	xx_uset(s, 0); xx_sumul_sum(s, a, b)
+#define xx_usub3(s, a, b)	_xx_usub3(s, ARRAY_SIZE(s), a, ARRAY_SIZE(a), b, ARRAY_SIZE(b))
+
+void _xx_uset(uxx_t *s, unsigned sn, unsigned val)
+{
+	unsigned i;
+	for (i = 0; i < sn; i++) {
+		*s++ = (uxx_t)val;
+		val >>= XX_GROUP;
+	}
+}
+
+int _xx_cmp(sxx_t *s, unsigned sn, unsigned val)
+{
+	int i = sn - 1;
+	{
+		int a0 = s[i];
+		if (a0 >> (XX_GROUP - 1))
+			return -1;
+	}
+	for (; i >= 0; i--) {
+		uxx_t a0 = s[i];
+		uxx_t b0 = (uxx_t)(val >> (XX_GROUP * i));
+		if (a0 < b0)
+			return -1;
+		if (a0 > b0)
+			return 1;
+	}
+	return 0;
+}
+
+int _xx_ucmp(uxx_t *s, unsigned sn, uxx_t *b, unsigned bn)
+{
+	int i;
+	while (sn > bn) {
+		if (s[sn - 1])
+			break;
+		sn--;
+	}
+	while (bn > sn) {
+		if (b[bn - 1])
+			break;
+		bn--;
+	}
+	if (sn != bn) {
+		if (sn > bn)
+			return 1;
+		return -1;
+	}
+	for (i = sn - 1; i >= 0; i--) {
+		if (s[i] > b[i])
+			return 1;
+		if (s[i] < b[i])
+			return -1;
+	}
+	return 0;
+}
+
+int _xx_uadd2(uxx_t *s, unsigned sn, uxx_t *b, unsigned bn)
+{
+	unsigned i;
+	unsigned min = (sn < bn) ? sn : bn;
+	uxx_t carry = 0;
+
+	for (i = 0; i < min; i++) {
+		uxx_t s0;
+		uxx_t a0 = *s;
+		uxx_t b0 = *b++;
+		s0 = a0 + carry;
+		carry = (s0 < a0) ? 1 : 0;
+		a0 = s0;
+		s0 += b0;
+		if (s0 < a0)
+			carry++;
+		*s++ = s0;
+	}
+	if (carry) {
+		for (; i < sn; i++) {
+			(*s)++;
+			if (*s++)
+				break;
+		}
+	}
+	return carry;
+}
+
+int _xx_usub2(uxx_t *s, unsigned sn, uxx_t *b, unsigned bn)
+{
+	unsigned i;
+	unsigned min = (sn < bn) ? sn : bn;
+	uxx_t borrow = 0;
+
+	for (i = 0; i < min; i++) {
+		uxx_t s0;
+		uxx_t a0 = *s;
+		uxx_t b0 = *b++;
+		s0 = a0 - borrow;
+		borrow = (s0 > a0) ? 1 : 0;
+		a0 = s0;
+		s0 -= b0;
+		if (s0 > a0)
+			borrow++;
+		*s++ = s0;
+	}
+	if (borrow) {
+		for (; i < sn; i++) {
+			if (*s) {
+				(*s)--;
+				break;
+			}
+			(*s)--;
+			s++;
+		}
+	}
+	return 0;
+}
+
+int _xx_usub3(sxx_t *s, unsigned sn, uxx_t *a, unsigned an, uxx_t *b, unsigned bn)
+{
+	unsigned i;
+	uxx_t borrow = 0;
+	for (i = 0; i < sn; i++) {
+		uxx_t s0;
+		uxx_t a0 = 0;
+		uxx_t b0 = 0;
+		if (i < an)
+			a0 = *a++;
+		if (i < bn)
+			b0 = *b++;
+		s0 = a0 - borrow;
+		borrow = (s0 > a0) ? 1 : 0;
+		a0 = s0;
+		s0 -= b0;
+		if (s0 > a0)
+			borrow++;
+		*s++ = s0;
+	}
+	return 0;
+}
+
+int _xx_reciprocal(uxx_t *s, unsigned sn, uxx_t *b, unsigned bn, uxx_t *rem, unsigned rem_n)
+{
+	unsigned i;
+	unsigned rn;
+	uxx_t t = 0;
+	_xx_uset(s, sn, 0);
+	_xx_uset(rem, rem_n, 0);
+	while (bn) {
+		t = b[bn - 1];
+		if (t)
+			break;
+		bn--;
+	}
+	rn = bn;
+	if (t >> (XX_GROUP - 1))
+		rn++;
+
+	if (rem_n < rn)
+		return -1;	/* rem array is too small */
+	rem[0] = 1;
+	for (i = 0; i < sn * XX_GROUP; i++) {
+		_xx_uadd2(rem, rn, rem, rn);
+		_xx_uadd2(s, sn, s, sn);
+		if (_xx_ucmp(rem, rn, b, bn) >= 0) {
+			_xx_usub2(rem, rn, b, bn);
+			s[0] |= 1;
+		}
+	}
+	return 0;
+}
+
+int _xx_get_val(sxx_t *s, unsigned sn, int *pshift, int shr)
+{
+	int shift = 0;
+	unsigned i;
+	int val;
+	unsigned sign_mask = 1 << (XX_GROUP - 1);
+	sxx_t a =  (s[sn - 1] & sign_mask) ? -1 : 0;
+	while (sn) {
+		if (s[sn - 1] != a)
+			break;
+		if (sn >= 2)
+			if ((s[sn - 2] ^ a) & sign_mask)
+				break;
+		sn--;
+	}
+
+	if (!sn) {
+		*pshift = -31 - shr;
+		return (a << 31);
+	}
+	for (;;) {
+		unsigned s0 = s[sn - 1];
+		if ((s0 ^ (s0 << 1)) >> (XX_GROUP - 1))
+			break;
+		_xx_uadd2(s, sn, s, sn);
+		shift--;
+	}
+	sn--;
+	val = s[sn];
+	for (i = 1; i < XUNIT; i++) {
+		unsigned s0 = 0;
+		if (sn) {
+			sn--;
+			s0 = s[sn];
+		} else {
+			shift -= XX_GROUP;
+		}
+		val <<= XX_GROUP;
+		val |= s0;
+	}
+	shift += (sn * XX_GROUP);
+	*pshift = shift - shr;
+	return val;
+}
+
+int _xx_umul_sum(uxx_t *s, unsigned sn, uxx_t *a, unsigned an, uxx_t *b, unsigned bn)
+{
+	unsigned i, j;
+	int overflow = 0;
+	uxx_t carry = 0;
+#if 0 //def DEBUG
+	printf("%s: sn=%d an=%d bn=%d\n", __func__, sn, an, bn);
+	printf("s=");
+	for (i = sn; i > 0; i--) {
+		printf("%x ", s[i - 1]);
+	}
+	printf("\na=");
+	for (i = an; i > 0; i--) {
+		printf("%x ", a[i - 1]);
+	}
+	printf("\nb=");
+	for (i = bn; i > 0; i--) {
+		printf("%x ", b[i - 1]);
+	}
+	printf("\n");
+#endif
+	for (i = 0; i < an; i++) {
+		uxx_t _a = a[i];
+		if (!_a)
+			continue;
+		for (j = 0; j < bn; j++) {
+			udxx_t v;
+			uxx_t d, t, high;
+			uxx_t _b = b[j];
+			if (!_b) {
+				if (carry) {
+					s[i + j + 1]++;
+					if (s[i + j + 1])
+						carry = 0;
+				}
+				continue;
+			}
+			v = ((udxx_t)_a) * _b;
+			if ((i + j) >= sn) {
+				overflow = 1;
+				break;
+			}
+			d = s[i + j];
+			t = d + (uxx_t)v;
+			s[i + j] = t;
+			high = (uxx_t)(v >> XX_GROUP);
+			if (t < d)
+				carry++; /* detect overflow */
+			if (!(carry | high))
+				continue;
+			if ((i + j + 1) >= sn) {
+				overflow = 1;
+				break;
+			}
+			d = s[i + j + 1];
+			t = d + carry;
+			carry = (t < d) ? 1 : 0; /* detect overflow */
+			d = t;
+			t += high;
+			s[i + j + 1] = t;
+			if (t < d)
+				carry++;
+		}
+		if (!carry)
+			continue;
+		for (j = i + bn + 1; j < sn; j++) {
+			s[j]++;
+			if (s[j]) {
+				carry = 0;
+				break;
+			}
+		}
+		if (carry) {
+			overflow = 1;
+			carry = 0;
+		}
+	}
+#if 0 //def DEBUG
+	printf("    result %s s=", overflow ? "overflow" : "");
+	for (i = sn; i > 0; i--) {
+		printf("%x ", s[i - 1]);
+	}
+	printf("\n");
+#endif
+	return overflow;
+}
+
+int _xx_sumul_sum(sxx_t *s, unsigned sn, sxx_t *a, unsigned an, uxx_t *b, unsigned bn)
+{
+#if 0 //def DEBUG
+	printf("%s\n", __func__);
+#endif
+	_xx_umul_sum(s, sn, (uxx_t *)a, an, b, bn);
+	if (sn > an) {
+		if (a[an - 1] >> (XX_GROUP - 1)) {
+			_xx_usub2(&s[an], sn - an, b, bn);
+#if 0 //def DEBUG
+			{
+				unsigned i;
+				printf("***sresult  s=");
+				for (i = sn; i > 0; i--) {
+					printf("%x ", s[i - 1]);
+				}
+				printf("\n");
+			}
+#endif
+		}
+	}
+	return 0;
+}
+#endif
+
+/*
+x = a1 i  +  a2 j + a3
+y = b1 i  +  b2 j + b3
+
+where x,y are screen coordinates and i,j are measured touch screen readings
+| x |  =  | a1  a2  a3 | | i |
+| y |     | b1  b2  b3 | | j |
+                         | 1 |
+
+| x1  x2  x3 |  =  | a1  a2  a3 | | i1 i2 i3 |
+| y1  y2  y3 |     | b1  b2  b3 | | j1 j2 j3 |
+                                  | 1   1  1 |
+where xn,yn are screen coordinates of where touched
+and   in,jn are measured readings when touched
+
+so
+
+| x1  x2  x3 |  | i1  i2  i3 | -1  =  | a1  a2  a3 |
+| y1  y2  y3 |  | j1  j2  j3 |        | b1  b2  b3 |
+                | 1   1    1 |
+
+any three non-linear points will determine a1,a2,a3, b1.b2,b3
+
+
+For multiple points, _ means summation
+| _x _xi _xj| = | a1 a2 a3 | | _i   _ii  _ij  |
+| _y _yi _yj|   | b1 b2 b3 | | _j   _ij  _jj  |
+                             |  n   _i   _j   |
+
+
+| _x _xi _xj|  | _i   _ii   _ij  | -1 = | a1 a2 a3 |
+| _y _yi _yj|  | _j   _ij   _jj  |      | b1 b2 b3 |
+               |  n   _i    _j   |
+
+in general when matrix
+A = | a11 a12 a13 |
+    | a21 a22 a23 |
+    | a31 a32 a33 |
+then
+A ^ -1 = 1/|A|  | |a22 a23| |a13 a12| |a12 a13| |
+		| |a32 a33| |a33 a32| |a22 a23| |
+		|				|
+		| |a23 a21| |a11 a13| |a13 a11| |
+		| |a33 a31| |a31 a33| |a23 a21| |
+		|				|
+		| |a21 a22| |a12 a11| |a11 a12| |
+		| |a31 a32| |a32 a31| |a21 a22| |
+or for us
+
+A ^ -1 = 1/|A|  | |_ij  _jj| |_ij  _ii| |_ii _ij| |
+		| |_i   _j | |_j   _i | |_ij _jj| |
+		|				  |
+		| |_jj  _j|  |_i _ij|   |_ij _i|  |
+		| |_j    n|  | n _j |   |_jj _j|  |
+		|				  |
+		| |_j  _ij|   |_ii _i|  |_i _ii|  |
+		| | n  _i |   |_i   n|  |_j _ij|  |
+
+or
+A ^ -1 = 1/|A|  | _ij*_j - _jj*_i,  _ij*_i - _ii*_j,  _ii*_jj - _ij*_ij	|
+		|			 	   			|
+		| n*_jj - _j*_j,    _i*_j - n*_ij,    _ij*_j - _i*_jj	|
+		|				  			|
+		| _j*_i - n*_ij,    n*_ii - _i*_i,   _i*_ij - _ii*_j	|
+*/
+
+int perform_calibration(struct cal_data *cal, int num_points, struct cal_result *res) {
+	int p;
+	int det_sign;
+	UXDECL(n, 1);
+	UXDECL(_x, 2);
+	UXDECL(_y, 2);
+	UXDECL(_i, 2);
+	UXDECL(_j, 2);
+	UXDECL(_xi, 3);
+	UXDECL(_xj, 3);
+	UXDECL(_yi, 3);
+	UXDECL(_yj, 3);
+	UXDECL(_ii, 3);
+	UXDECL(_jj, 3);
+	UXDECL(_ij, 3);
+	UXDECL(_i_jj, 5);
+	UXDECL(_i_ij, 5);
+	UXDECL(_j_ij, 5);
+	UXDECL(_j_ii, 5);
+	UXDECL(_ii_jj, 6);
+	UXDECL(_ij_ij, 6);
+	SXDECL(a, 6);
+	SXDECL(b, 5);
+	SXDECL(c, 5);
+	SXDECL(d, 6);
+	SXDECL(f, 5);
+	SXDECL(g, 7);
+	SXDECL(det, 9);
+//	UXDECL(tmp, 10);
+	UXDECL(stmp, 10);
+	UXDECL(idet, 10);
+	UXDECL(stmp2, 20);
+
+	UXDECL(n_ii, 4);
+	UXDECL(n_ij, 4);
+	UXDECL(n_jj, 4);
+	UXDECL(_i_i, 4);
+	UXDECL(_i_j, 4);
+	UXDECL(_j_j, 4);
+	int shift[6];
+	int val[6];
+	int max_shift;
+
+	xx_uset(n, num_points);
+	xx_uset(_x, 0);
+	xx_uset(_y, 0);
+	xx_uset(_i, 0);
+	xx_uset(_j, 0);
+
+	xx_uset(_xi, 0);
+	xx_uset(_xj, 0);
+	xx_uset(_yi, 0);
+	xx_uset(_yj, 0);
+	xx_uset(_ii, 0);
+	xx_uset(_jj, 0);
+	xx_uset(_ij, 0);
+
+// Get sums for matrix
+	for (p = 0; p < num_points; p++) {
+		struct cal_data *d = &cal[p];
+		UXDECL(x, 1);
+		UXDECL(y, 1);
+		UXDECL(i, 1);
+		UXDECL(j, 1);
+		xx_uset(x, d->x);
+		xx_uset(y, d->y);
+		xx_uset(i, d->i);
+		xx_uset(j, d->j);
+		xx_uadd2(_x, x);
+		xx_uadd2(_y, y);
+		xx_uadd2(_i, i);
+		xx_uadd2(_j, j);
+		xx_umul_sum(_xi, x, i);
+		xx_umul_sum(_xj, x, j);
+		xx_umul_sum(_yi, y, i);
+		xx_umul_sum(_yj, y, j);
+		xx_umul_sum(_ii, i, i);
+		xx_umul_sum(_jj, j, j);
+		xx_umul_sum(_ij, i, j);
+	}
+/*
+ * find determinant of
+ * | _i   _ii  _ij  |
+ * | _j   _ij  _jj  |
+ * |  n   _i   _j   |
+ */
+	xx_umul(_i_jj, _i, _jj);
+	xx_umul(_i_ij, _i, _ij);
+	xx_umul(_j_ij, _j, _ij);
+	xx_umul(_j_ii, _j, _ii);
+	xx_umul(_ii_jj, _ii, _jj);
+	xx_umul(_ij_ij, _ij, _ij);
+	xx_usub3(a, _j_ij, _i_jj);
+	xx_usub3(d, _i_ij, _j_ii);
+	xx_usub3(g, _ii_jj, _ij_ij);
+
+	xx_sumul(det, a, _i);
+	xx_sumul_sum(det, d, _j);
+	xx_sumul_sum(det, g, n);
+
+	det_sign = xx_cmp(det, 0);
+	if (!det_sign) {
+		printf("ts_calibrate: determinant is zero\n");
+		return -1;
+	}
+	if (det_sign < 0)
+		xx_neg(det);
+	xx_reciprocal(idet, det, tmp);
+
+/*
+ * Get elements of inverse matrix
+ *	A ^ -1 = 1/|A|  | a(h) = _j*_ij - _i*_jj,  d(i) = _i*_ij - _j*_ii,  g = _ii*_jj - _ij*_ij	|
+ *			| b = n*_jj - _j*_j,       e(c) = _i*_j - n*_ij,    h(a) =  _j*_ij - _i*_jj	|
+ *			| c(e) = _i*_j - n*_ij,    f = n*_ii - _i*_i,       i(d) =  _i*_ij - _j*_ii	|
+ */
+	xx_umul(n_ii, n, _ii);
+	xx_umul(n_ij, n, _ij);
+	xx_umul(n_jj, n, _jj);
+	xx_umul(_i_i, _i, _i);
+	xx_umul(_i_j, _i, _j);
+	xx_umul(_j_j, _j, _j);
+
+	xx_usub3(b, n_jj, _j_j);
+	xx_usub3(c, _i_j, n_ij);
+	xx_usub3(f, n_ii, _i_i);
+
+// Now multiply out to get the calibration for framebuffer x coord
+	xx_sumul(stmp, a, _x);
+	xx_sumul_sum(stmp, b, _xi);
+	xx_sumul_sum(stmp, c, _xj);	/* a*_x + b*_xi + c*_xj */
+	xx_sumul(stmp2, stmp, idet);
+	val[0] = xx_get_val(stmp2, &shift[0], sizeof(idet) * 8);
+
+	xx_sumul(stmp, d, _x);
+	xx_sumul_sum(stmp, c, _xi);
+	xx_sumul_sum(stmp, f, _xj);	/* d*_x + c*_xi + f*_xj */
+	xx_sumul(stmp2, stmp, idet);
+	val[1] = xx_get_val(stmp2, &shift[1], sizeof(idet) * 8);
+
+	xx_sumul(stmp, g, _x);
+	xx_sumul_sum(stmp, a, _xi);
+	xx_sumul_sum(stmp, d, _xj);	/* g*_x + a*_xi + d*_xj */
+	xx_sumul(stmp2, stmp, idet);
+	val[2] = xx_get_val(stmp2, &shift[2], sizeof(idet) * 8);
+
+// Now multiply out to get the calibration for framebuffer y coord
+	xx_sumul(stmp, a, _y);
+	xx_sumul_sum(stmp, b, _yi);
+	xx_sumul_sum(stmp, c, _yj);	/* a*_y + b*_yi + c*_yj */
+	xx_sumul(stmp2, stmp, idet);
+	val[3] = xx_get_val(stmp2, &shift[3], sizeof(idet) * 8);
+
+	xx_sumul(stmp, d, _y);
+	xx_sumul_sum(stmp, c, _yi);
+	xx_sumul_sum(stmp, f, _yj);	/* d*_y + c*_yi + f*_yj */
+	xx_sumul(stmp2, stmp, idet);
+	val[4] = xx_get_val(stmp2, &shift[4], sizeof(idet) * 8);
+
+	xx_sumul(stmp, g, _y);
+	xx_sumul_sum(stmp, a, _yi);
+	xx_sumul_sum(stmp, d, _yj);	/* g*_y + a*_yi + d*_yj */
+	xx_sumul(stmp2, stmp, idet);
+	val[5] = xx_get_val(stmp2, &shift[5], sizeof(idet) * 8);
+
+	max_shift = -20;
+	for (p = 0; p < 6; p++) {
+		if (max_shift < shift[p])
+			max_shift = shift[p];
+	}
+	for (p = 0; p < 6; p++) {
+		int sh = max_shift - shift[p];
+		int v = val[p] >> sh;
+		if (det_sign < 0)
+			v = -v;
+		res->a[p] = v;
+	}
+#ifdef DEBUG
+	{
+		int shift;
+		int val = xx_get_val(det, &shift, 0);
+		printf("max_shift=%d det=%x shl %i det_sign=%i\n", max_shift, val, shift, det_sign);
+	}
+#endif
+#ifdef DEBUG
+	{
+		int shr = -max_shift;
+		int a = res->a[0];
+		int b = res->a[1];
+		int c = res->a[2];
+		char as = ' ';
+		char bs = ' ';
+		char cs = ' ';
+		if (shr < 0)
+			shr = 0;
+		if (a < 0) {
+			as = '-';
+			a = -a;
+		}
+		if (b < 0) {
+			bs = '-';
+			b = -b;
+		}
+		if (c < 0) {
+			cs = '-';
+			c = -c;
+		}
+		printf("%c%x(%c%i.%03i) %c%x(%c%i.%03i) %c%x(%c%i.%03i)\n",
+			as, a, as, a >> shr, ((a - ((a >> shr) << shr)) * 1000) >> shr,
+			bs, b, bs, b >> shr, ((b - ((b >> shr) << shr)) * 1000) >> shr,
+			cs, c, cs, c >> shr, ((c - ((c >> shr) << shr)) * 1000) >> shr);
+		a = res->a[3];
+		b = res->a[4];
+		c = res->a[5];
+		as = ' ';
+		bs = ' ';
+		cs = ' ';
+		if (a < 0) {
+			as = '-';
+			a = -a;
+		}
+		if (b < 0) {
+			bs = '-';
+			b = -b;
+		}
+		if (c < 0) {
+			cs = '-';
+			c = -c;
+		}
+		printf("%c%x(%c%i.%03i) %c%x(%c%i.%03i) %c%x(%c%i.%03i)\n",
+			as, a, as, a >> shr, ((a - ((a >> shr) << shr)) * 1000) >> shr,
+			bs, b, bs, b >> shr, ((b - ((b >> shr) << shr)) * 1000) >> shr,
+			cs, c, cs, c >> shr, ((c - ((c >> shr) << shr)) * 1000) >> shr);
+	}
+#endif
+	res->shift = max_shift;
+	return 0;
+}
+
+int perform_q_calibration(struct cal_data *cal,  struct cal_result *res)
+{
+	int r;
+	struct cal_data c3[3];
+	r = perform_calibration(cal, 5, &res[QUAD_MAIN]);
+	c3[0] = cal[PT_MM];
+	c3[2] = cal[PT_RT];
+	c3[1] = cal[PT_LT];
+	if (r >= 0)
+		r = perform_calibration(c3, 3, &res[QUAD_TOP]);
+	c3[2] = cal[PT_LB];
+	if (r >= 0)
+		r = perform_calibration(c3, 3, &res[QUAD_LEFT]);
+	c3[1] = cal[PT_RB];
+	if (r >= 0)
+		r = perform_calibration(c3, 3, &res[QUAD_BOTTOM]);
+	c3[2] = cal[PT_RT];
+	if (r >= 0)
+		r = perform_calibration(c3, 3, &res[QUAD_RIGHT]);
+	return r;
+}
+
diff --git a/src/tsquadrant_cal.h b/src/tsquadrant_cal.h
new file mode 100644
index 0000000..8d282ae
--- /dev/null
+++ b/src/tsquadrant_cal.h
@@ -0,0 +1,39 @@
+#include <tslib.h>
+
+#define u64 unsigned long long
+#define s32 int
+#define u32 unsigned int
+#define s64 long long
+
+struct cal_data {
+	u32	x;	/* framebuffer position */
+	u32	y;
+	u32	i;	/* touchscreen reading for point */
+	u32	j;
+};
+
+struct cal_result {
+	int shift;
+	s32 a[12];
+};
+
+#define PT_LT		0
+#define PT_RT		1
+#define PT_RB		2
+#define PT_LB		3
+#define PT_MM		4
+#define PT_MT		5
+#define PT_MB		6
+#define PT_LM		7
+#define PT_RM		8
+
+#define QUAD_MAIN   0
+#define QUAD_TOP    1
+#define QUAD_LEFT   2
+#define QUAD_BOTTOM 3
+#define QUAD_RIGHT  4
+
+TSAPI extern int perform_q_calibration(struct cal_data *cal, struct cal_result *res);
+TSAPI extern int perform_n_point_calibration(struct cal_data *cal,
+		int num_points, u32 xmax, u32 ymax, u32 imax, u32 jmax,
+		struct cal_result *res);
diff --git a/tests/Makefile.am b/tests/Makefile.am
index b76522d..09dae09 100644
--- a/tests/Makefile.am
+++ b/tests/Makefile.am
@@ -11,19 +11,22 @@
 AM_CFLAGS               = -DTS_POINTERCAL=\"@TS_POINTERCAL@\" $(DEBUGFLAGS)
 INCLUDES		= -I$(top_srcdir)/src
 
-bin_PROGRAMS		= ts_test ts_calibrate ts_print ts_print_raw ts_harvest
+bin_PROGRAMS		= ts_test ts_calibrate ts_calibrate_quadrant ts_print ts_print_raw ts_harvest
 
 ts_test_SOURCES		= ts_test.c fbutils.c fbutils.h font_8x8.c font_8x16.c font.h
 ts_test_LDADD		= $(top_builddir)/src/libts.la
 
-ts_print_SOURCES	= ts_print.c
+ts_print_SOURCES	= ts_print.c fbutils.c fbutils.h testutils.c testutils.h font_8x8.c font_8x16.c font.h
 ts_print_LDADD		= $(top_builddir)/src/libts.la
 
-ts_print_raw_SOURCES	= ts_print_raw.c
+ts_print_raw_SOURCES	= ts_print_raw.c fbutils.c fbutils.h testutils.c testutils.h font_8x8.c font_8x16.c font.h
 ts_print_raw_LDADD	= $(top_builddir)/src/libts.la
 
 ts_calibrate_SOURCES	= ts_calibrate.c fbutils.c fbutils.h testutils.c testutils.h font_8x8.c font_8x16.c font.h
 ts_calibrate_LDADD	= $(top_builddir)/src/libts.la
 
+ts_calibrate_quadrant_SOURCES	= ts_calibrate_quadrant.c fbutils.c fbutils.h testutils.c testutils.h font_8x8.c font_8x16.c font.h
+ts_calibrate_quadrant_LDADD	= $(top_builddir)/src/libts.la
+
 ts_harvest_SOURCES	= ts_harvest.c fbutils.c fbutils.h testutils.c testutils.h font_8x8.c font_8x16.c font.h
 ts_harvest_LDADD		= $(top_builddir)/src/libts.la
diff --git a/tests/fbutils.c b/tests/fbutils.c
index fd7a0ed..1432c1c 100644
--- a/tests/fbutils.c
+++ b/tests/fbutils.c
@@ -42,7 +42,7 @@ static unsigned char **line_addr;
 static int fb_fd=0;
 static int bytes_per_pixel;
 static unsigned colormap [256];
-__u32 xres, yres;
+__u32 xres, yres, rotate_mode;
 
 static char *defaultfbdevice = "/dev/fb0";
 static char *defaultconsoledevice = "/dev/tty";
@@ -126,8 +126,8 @@ int open_framebuffer(void)
 		close(fb_fd);
 		return -1;
 	}
-	xres = var.xres;
-	yres = var.yres;
+	xres = (rotate_mode & 4) ? var.yres : var.xres;
+	yres = (rotate_mode & 4) ? var.xres : var.yres;
 
 	fbuffer = mmap(NULL, fix.smem_len, PROT_READ | PROT_WRITE, MAP_FILE | MAP_SHARED, fb_fd, 0);
 	if (fbuffer == (unsigned char *)-1) {
@@ -297,13 +297,27 @@ static inline void __setpixel (union multiptr loc, unsigned xormode, unsigned co
 	}
 }
 
+unsigned char *get_fb_location(int x, int y, int mode)
+{
+	if (mode & 1)
+		y = yres - y - 1;
+	if (mode & 2)
+		x = xres - x - 1;
+	if (mode & 4) {
+		unsigned t = x;
+
+		x = y;
+		y = t;
+	}
+	return line_addr[y] + x * bytes_per_pixel;
+}
+
 void pixel (int x, int y, unsigned colidx)
 {
 	unsigned xormode;
 	union multiptr loc;
 
-	if ((x < 0) || ((__u32)x >= var.xres_virtual) ||
-	    (y < 0) || ((__u32)y >= var.yres_virtual))
+	if ( ((__u32)x >= xres) || ((__u32)y >= yres) )
 		return;
 
 	xormode = colidx & XORMODE;
@@ -317,7 +331,7 @@ void pixel (int x, int y, unsigned colidx)
 	}
 #endif
 
-	loc.p8 = line_addr [y] + x * bytes_per_pixel;
+	loc.p8 = get_fb_location(x, y, rotate_mode);
 	__setpixel (loc, xormode, colormap [colidx]);
 }
 
@@ -396,10 +410,9 @@ void fillrect (int x1, int y1, int x2, int y2, unsigned colidx)
 	colidx = colormap [colidx];
 
 	for (; y1 <= y2; y1++) {
-		loc.p8 = line_addr [y1] + x1 * bytes_per_pixel;
 		for (tmp = x1; tmp <= x2; tmp++) {
+			loc.p8 = get_fb_location(tmp, y1, rotate_mode);
 			__setpixel (loc, xormode, colidx);
-			loc.p8 += bytes_per_pixel;
 		}
 	}
 }
diff --git a/tests/fbutils.h b/tests/fbutils.h
index 48890f7..572a4fc 100644
--- a/tests/fbutils.h
+++ b/tests/fbutils.h
@@ -21,7 +21,16 @@
  */
 #define XORMODE	0x80000000
 
-extern __u32 xres, yres;
+#define ROTATE_NONE		0
+#define ROTATE_VERT_FLIP	1
+#define ROTATE_HORIZ_FLIP	2
+#define ROTATE_180		3
+#define ROTATE_90_RIGHT_HFLIP	4
+#define ROTATE_90_RIGHT		5
+#define ROTATE_90_LEFT		6
+#define ROTATE_90_RIGHT_VFLIP	7
+
+extern __u32 xres, yres, rotate_mode;
 
 int open_framebuffer(void);
 void close_framebuffer(void);
diff --git a/tests/ts_calibrate.c b/tests/ts_calibrate.c
index eb0aca3..ba9c3b4 100644
--- a/tests/ts_calibrate.c
+++ b/tests/ts_calibrate.c
@@ -193,7 +193,6 @@ int main()
 	calibration cal;
 	int cal_fd;
 	char cal_buffer[256];
-	char *tsdevice = NULL;
 	char *calfile = NULL;
 	unsigned int i, len;
 
@@ -201,24 +200,14 @@ int main()
 	signal(SIGINT, sig);
 	signal(SIGTERM, sig);
 
-	if( (tsdevice = getenv("TSLIB_TSDEVICE")) != NULL ) {
-		ts = ts_open(tsdevice,0);
-	} else {
-		if (!(ts = ts_open("/dev/input/event0", 0)))
-			ts = ts_open("/dev/touchscreen/ucb1x00", 0);
-	}
-
-	if (!ts) {
-		perror("ts_open");
-		exit(1);
-	}
-	if (ts_config(ts)) {
-		perror("ts_config");
+	if (open_framebuffer()) {
+		close_framebuffer();
 		exit(1);
 	}
 
-	if (open_framebuffer()) {
-		close_framebuffer();
+	ts = ts_open_config(0, xres, yres);
+	if (!ts) {
+		perror("ts_open_config");
 		exit(1);
 	}
 
diff --git a/tests/ts_calibrate_quadrant.c b/tests/ts_calibrate_quadrant.c
new file mode 100644
index 0000000..e2c93f5
--- /dev/null
+++ b/tests/ts_calibrate_quadrant.c
@@ -0,0 +1,331 @@
+/*
+ *  tslib/tests/ts_calibrate.c
+ *
+ *  Copyright (C) 2001 Russell King.
+ *
+ * This file is placed under the GPL.  Please see the file
+ * COPYING for more details.
+ *
+ * $Id: ts_calibrate.c,v 1.8 2004/10/19 22:01:27 dlowder Exp $
+ *
+ * Basic test program for touchscreen library.
+ */
+#include "config.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <signal.h>
+#include <string.h>
+#include <unistd.h>
+#include <sys/stat.h>
+#include <sys/fcntl.h>
+#include <sys/ioctl.h>
+#include <sys/mman.h>
+#include <sys/time.h>
+#include <getopt.h>
+#include <linux/kd.h>
+#include <linux/vt.h>
+#include <linux/fb.h>
+#include <linux/input.h>
+#include "tslib-private.h"
+
+#include "tslib.h"
+
+#include "fbutils.h"
+#include "testutils.h"
+#include "tsquadrant_cal.h"
+
+static int palette [] =
+{
+	0x000000, 0xffe080, 0xffffff, 0xe0c0a0
+};
+#define NR_COLORS (sizeof (palette) / sizeof (palette [0]))
+
+static void sig(int sig)
+{
+	close_framebuffer ();
+	fflush (stderr);
+	printf ("signal %d caught\n", sig);
+	fflush (stdout);
+	exit (1);
+}
+
+static void get_sample (struct tsdev *ts, struct cal_data *cal,
+		int x, int y, char *name)
+{
+	static int last_x = -1, last_y;
+
+	if (last_x != -1) {
+#define NR_STEPS 10
+		int dx = ((x - last_x) << 16) / NR_STEPS;
+		int dy = ((y - last_y) << 16) / NR_STEPS;
+		int i;
+		last_x <<= 16;
+		last_y <<= 16;
+		for (i = 0; i < NR_STEPS; i++) {
+			put_cross (last_x >> 16, last_y >> 16, 2 | XORMODE);
+			usleep (1000);
+			put_cross (last_x >> 16, last_y >> 16, 2 | XORMODE);
+			last_x += dx;
+			last_y += dy;
+		}
+	}
+
+	put_cross(x, y, 2 | XORMODE);
+	getxy(ts, (int*)&cal->i, (int*)&cal->j);
+	put_cross(x, y, 2 | XORMODE);
+
+	last_x = cal->x = x;
+	last_y = cal->y = y;
+
+	printf("%s : X = %4d Y = %4d\n", name, cal->i, cal->j);
+}
+
+struct opts {
+	int xinput_format;
+};
+
+void print_usage(void)
+{
+	printf("Usage: ts_calibrate_quadrant [OPTIONS...]\n"
+		"Where OPTIONS are\n"
+		"   -h --help		Show this help\n"
+		"   -x --xinput		xinput output format\n"
+		"   -r --rotate180	screen is upside down\n"
+		"   -R --rotate_right	rotate 90 degrees right(cw)\n"
+		"   -L --rotate_left	rotate 90 degrees left(ccw)\n"
+		"   -m --rotate_mode n	0 - normal, 1 - vflip, 2 - hflip, 3 - 180,\n"
+		"\t\t4 - swap x/y, 5 - right 90(cw), 6 - left 90(ccw), 7 - swap x/y 180\n"
+		"\n");
+}
+
+int parse_opts(int argc, char * const *argv, struct opts *opts)
+{
+	int c;
+
+	static struct option long_options[] = {
+		{"help",	no_argument, 		0, 'h' },
+		{"rotate180",   no_argument,            0, 'r' },
+		{"xinput",	no_argument, 		0, 'x' },
+		{"rotate_right", no_argument,		0, 'R' },
+		{"rotate_left", no_argument,		0, 'L' },
+		{"rotate_mode", required_argument,	0, 'm' },
+		{0,		0,			0, 0 },
+	};
+
+	while ((c = getopt_long(argc, argv, "+hxrRLm:", long_options, NULL)) != -1) {
+		switch (c)
+		{
+		case 'x':
+			opts->xinput_format = 1;
+			break;
+		case 'r':
+			rotate_mode = ROTATE_180;
+			break;
+		case 'R':
+			rotate_mode = ROTATE_90_RIGHT;
+			break;
+		case 'L':
+			rotate_mode = ROTATE_90_LEFT;
+			break;
+		case 'm' :
+			sscanf(optarg, "%i", &rotate_mode);
+			if (rotate_mode > 7)
+				rotate_mode = 0;
+			break;
+		case 'h':
+		case '?':
+		default:
+			print_usage();
+			return -1;
+		}
+	}
+	return 0;
+}
+
+int main(int argc, char * const argv[])
+{
+	struct tsdev *ts;
+	struct cal_data cal[9];
+	struct cal_result res[5];
+	int cal_fd;
+	char cal_buffer[256];
+	char device_name[260];
+	char *calfile = NULL;
+	unsigned int i;
+	int r;
+	int dx, dy;
+	unsigned nconst = 6;
+	unsigned ngroups = 5;
+	unsigned npoints;
+	struct input_absinfo abs;
+	int iMax = 2048;
+	int jMax = 2048;
+	struct opts opts;
+	int err;
+
+	memset(&opts, 0, sizeof(struct opts));
+	err = parse_opts(argc, argv, &opts);
+	if (err)
+		exit(1);
+
+	signal(SIGSEGV, sig);
+	signal(SIGINT, sig);
+	signal(SIGTERM, sig);
+
+	/* get xres, yres */
+	if (open_framebuffer()) {
+		close_framebuffer();
+		exit(1);
+	}
+
+	ts = ts_open_config(0, xres, yres);
+	if (!ts) {
+		perror("ts_open_config");
+		exit(1);
+	}
+
+	if (ioctl(ts->fd, EVIOCGABS(0), &abs) == 0) {
+		iMax = abs.maximum + 1;
+		printf("iMax = %d\n", iMax);
+	} else {
+		printf("iMax read error, defaulting to 2048\n");
+	}
+	if (ioctl(ts->fd, EVIOCGABS(1), &abs) == 0) {
+		jMax = abs.maximum + 1;
+		printf("jMax = %d\n", jMax);
+	} else {
+		printf("jMax read error, defaulting to 2048\n");
+	}
+	i = ioctl(ts->fd, EVIOCGNAME(256), device_name);
+	if (i > 0) {
+		device_name[i] = 0;
+		printf("device_name = %s\n", device_name);
+	} else {
+		printf("device_name read error\n");
+		device_name[0] = 0;
+	}
+
+	for (i = 0; i < NR_COLORS; i++)
+		setcolor (i, palette [i]);
+
+	put_string_center (xres / 2, yres / 4,
+			   "TSLIB calibration utility", 1);
+	put_string_center (xres / 2, yres / 4 + 20,
+			   "Touch crosshair to calibrate", 2);
+
+	printf("xres = %d, yres = %d\n", xres, yres);
+
+// Read a touchscreen event to clear the buffer
+	//getxy(ts, 0, 0);
+
+	dy = 50;
+	dx = (dy * xres) / yres;
+	npoints = opts.xinput_format ? 5 : 9;
+
+	if (PT_LT < npoints)
+		get_sample(ts, &cal[PT_LT], dx,            dy,            "left top");
+	if (PT_MT < npoints)
+		get_sample(ts, &cal[PT_MT], xres / 2,      dy,            "mid top ");
+	if (PT_RT < npoints)
+		get_sample(ts, &cal[PT_RT], xres - 1 - dx, dy,            "right top");
+
+	if (PT_LM < npoints)
+		get_sample(ts, &cal[PT_LM], dx,            yres / 2,      "left mid");
+	if (PT_MM < npoints)
+		get_sample(ts, &cal[PT_MM], xres / 2,      yres / 2,      "Center");
+	if (PT_RM < npoints)
+		get_sample(ts, &cal[PT_RM], xres - 1 - dx, yres / 2,      "right mid");
+
+	if (PT_LB < npoints)
+		get_sample(ts, &cal[PT_LB], dx,            yres - 1 - dy, "left bottom");
+	if (PT_MB < npoints)
+		get_sample(ts, &cal[PT_MB], xres / 2,      yres - 1 - dy, "mid bottom");
+	if (PT_RB < npoints)
+		get_sample(ts, &cal[PT_RB], xres - 1 - dx, yres - 1 - dy, "right bottom");
+
+	r = perform_n_point_calibration(cal, npoints, xres, yres, iMax, jMax, res);
+	if (r >= 0) {
+		int ret;
+		unsigned q;
+
+		nconst = 12;
+		ngroups = 1;
+
+		printf ("Calibration constants: ");
+		for (q = 0; q < ngroups; q++) {
+			for (i = 0; i < nconst; i++)
+				printf("%d ", res[q].a[i]);
+			printf("shift %d\n", res[q].shift);
+		}
+		calfile = getenv("TSLIB_CALIBFILE");
+		if (!calfile)
+			calfile = TS_POINTERCAL;
+		cal_fd = open(calfile, O_TRUNC | O_CREAT | O_RDWR, S_IRWXU | S_IRWXG | S_IRWXO);
+		printf("calibrate file: %s\n", calfile);
+		for (i = 0; i < npoints; i++) {
+			struct cal_data *d = &cal[i];
+			int length = sprintf(cal_buffer,"(%d,%d)(%d,%d)\n",
+				 d->x, d->y, d->i, d->j);
+			ret = write(cal_fd, cal_buffer, length);
+//			printf("%s", cal_buffer);
+			if (ret < length)
+				printf("write returned %d, expected %d\n", ret, length);
+		}
+		close(cal_fd);
+
+		if (ngroups == 1) {
+			char *p = strncpy(cal_buffer, calfile, sizeof(cal_buffer) - 3);
+			int nleft;
+			int len;
+			p[sizeof(cal_buffer) - 3] = 0;
+			p += strlen(p);
+			*p++ = '_';
+			*p++ = opts.xinput_format ? 'x' : 'c';
+			*p = 0;
+
+			cal_fd = open(cal_buffer, O_TRUNC | O_CREAT | O_RDWR, S_IRWXU | S_IRWXG | S_IRWXO);
+			printf("coefficient file: %s\n", cal_buffer);
+			p = cal_buffer;
+			nleft = sizeof(cal_buffer);
+			if (opts.xinput_format) {
+				float f[6];
+
+				f[2] = (float)res[0].a[0] / 65536;
+				f[0] = (float)res[0].a[1] / 65536;
+				f[1] = (float)res[0].a[2] / 65536;
+				f[5] = (float)res[0].a[6] / 65536;
+				f[3] = (float)res[0].a[7] / 65536;
+				f[4] = (float)res[0].a[8] / 65536;
+				len = snprintf(p, nleft, "\"%s\" \"Coordinate Transformation Matrix\" "
+						"%.5f %.5f %.5f %.5f %.5f %.5f 0 0 1\n",
+						device_name, f[0], f[1], f[2], f[3], f[4], f[5]);
+				if (nleft > len) {
+					nleft -= len;
+					p += len;
+				}
+			} else {
+				for (i = 0; i < nconst; i++) {
+					len = snprintf(p, nleft, (i != (nconst - 1)) ? "%d," : "%d\n", res[0].a[i]);
+
+					if (len >= nleft)
+						break;
+					nleft -= len;
+					p += len;
+				}
+			}
+			len = sizeof(cal_buffer) - nleft;
+			ret = write(cal_fd, cal_buffer, len);
+			if (ret < len)
+				printf("write returned %d, expected %d\n", ret, len);
+			close(cal_fd);
+		}
+                i = 0;
+	} else {
+		printf("Calibration failed.\n");
+		i = -1;
+	}
+
+	close_framebuffer();
+	return i;
+}
diff --git a/tests/ts_harvest.c b/tests/ts_harvest.c
index 05b8853..1d77c51 100644
--- a/tests/ts_harvest.c
+++ b/tests/ts_harvest.c
@@ -66,32 +66,20 @@ int main()
 	int x_ts, y_ts, x_incr, y_incr;
 	unsigned int x, y, xres_half, yres_half, x_new, y_new;
 	unsigned int i;
-	char *tsdevice=NULL;
 	FILE *output_fid;
 
 	signal(SIGSEGV, sig);
 	signal(SIGINT, sig);
 	signal(SIGTERM, sig);
 
-	if( (tsdevice = getenv("TSLIB_TSDEVICE")) != NULL ) {
-		ts = ts_open(tsdevice,0);
-	} else {
-		if (!(ts = ts_open("/dev/input/event0", 0)))
-			ts = ts_open("/dev/touchscreen/ucb1x00", 0);
-	}
-
-	if (!ts) {
-		perror("ts_open");
-		exit(1);
-	}
-
-	if (ts_config(ts)) {
-		perror("ts_config");
+	if (open_framebuffer()) {
+		close_framebuffer();
 		exit(1);
 	}
 
-	if (open_framebuffer()) {
-		close_framebuffer();
+	ts = ts_open_config(0, xres, yres);
+	if (!ts) {
+		perror("ts_open_config");
 		exit(1);
 	}
 
diff --git a/tests/ts_print.c b/tests/ts_print.c
index b2a7b85..e86c89b 100644
--- a/tests/ts_print.c
+++ b/tests/ts_print.c
@@ -18,27 +18,21 @@
 #include <sys/time.h>
 
 #include "tslib.h"
+#include "fbutils.h"
 
 
 int main()
 {
 	struct tsdev *ts;
-	char *tsdevice=NULL;
 
-	if( (tsdevice = getenv("TSLIB_TSDEVICE")) != NULL ) {
-		ts = ts_open(tsdevice,0);
-	} else {
-		if (!(ts = ts_open("/dev/input/event0", 0)))
-			ts = ts_open("/dev/touchscreen/ucb1x00", 0);
-	}
-
-	if (!ts) {
-		perror("ts_open");
+	if (open_framebuffer()) {
+		close_framebuffer();
 		exit(1);
 	}
-
-	if (ts_config(ts)) {
-		perror("ts_config");
+	close_framebuffer();
+	ts = ts_open_config(0, xres, yres);
+	if (!ts) {
+		perror("ts_open_config");
 		exit(1);
 	}
 
diff --git a/tests/ts_print_raw.c b/tests/ts_print_raw.c
index 9c103f2..cf9f223 100644
--- a/tests/ts_print_raw.c
+++ b/tests/ts_print_raw.c
@@ -18,27 +18,21 @@
 #include <sys/time.h>
 
 #include "tslib.h"
+#include "fbutils.h"
 
 
 int main()
 {
 	struct tsdev *ts;
-	char *tsdevice=NULL;
 
-	if( (tsdevice = getenv("TSLIB_TSDEVICE")) != NULL ) {
-		ts = ts_open(tsdevice,0);
-	} else {
-		if (!(ts = ts_open("/dev/input/event0", 0)))
-			ts = ts_open("/dev/touchscreen/ucb1x00", 0);
-	}
-
-	if (!ts) {
-		perror("ts_open");
+	if (open_framebuffer()) {
+		close_framebuffer();
 		exit(1);
 	}
-
-	if (ts_config(ts)) {
-		perror("ts_config");
+	close_framebuffer();
+	ts = ts_open_config(0, xres, yres);
+	if (!ts) {
+		perror("ts_open_config");
 		exit(1);
 	}
 
diff --git a/tests/ts_test.c b/tests/ts_test.c
index fbbc9b8..6187568 100644
--- a/tests/ts_test.c
+++ b/tests/ts_test.c
@@ -19,6 +19,7 @@
 #include <sys/ioctl.h>
 #include <sys/mman.h>
 #include <sys/time.h>
+#include <getopt.h>
 
 #include "tslib.h"
 #include "fbutils.h"
@@ -105,39 +106,85 @@ static void refresh_screen ()
 		button_draw (&buttons [i]);
 }
 
-int main()
+void print_usage(void)
+{
+	printf("Usage: ts_test [OPTIONS...]\n"
+		"Where OPTIONS are\n"
+		"   -h --help		Show this help\n"
+		"   -r --rotate180	screen is upside down\n"
+		"   -R --rotate_right	rotate 90 degrees right(cw)\n"
+		"   -L --rotate_left	rotate 90 degrees left(ccw)\n"
+		"   -m --rotate_mode n	0 - normal, 1 - vflip, 2 - hflip, 3 - 180,\n"
+		"\t\t4 - swap x/y, 5 - right 90(cw), 6 - left 90(ccw), 7 - swap x/y 180\n"
+		"\n");
+}
+
+int parse_opts(int argc, char * const *argv)
+{
+	int c;
+
+	static struct option long_options[] = {
+		{"help",	no_argument, 		0, 'h' },
+		{"rotate180",   no_argument,            0, 'r' },
+		{"rotate_right", no_argument,		0, 'R' },
+		{"rotate_left", no_argument,		0, 'L' },
+		{"rotate_mode", required_argument,	0, 'm' },
+		{0,		0,			0, 0 },
+	};
+
+	while ((c = getopt_long(argc, argv, "+hrRLm:", long_options, NULL)) != -1) {
+		switch (c)
+		{
+		case 'r':
+			rotate_mode = ROTATE_180;
+			break;
+		case 'R':
+			rotate_mode = ROTATE_90_RIGHT;
+			break;
+		case 'L':
+			rotate_mode = ROTATE_90_LEFT;
+			break;
+		case 'm' :
+			sscanf(optarg, "%i", &rotate_mode);
+			if (rotate_mode > 7)
+				rotate_mode = 0;
+			break;
+		case 'h':
+		case '?':
+		default:
+			print_usage();
+			return -1;
+		}
+	}
+	return 0;
+}
+
+int main(int argc, char * const argv[])
 {
 	struct tsdev *ts;
 	int x, y;
 	unsigned int i;
 	unsigned int mode = 0;
 	int quit_pressed = 0;
+	int err;
 
-	char *tsdevice=NULL;
+	err = parse_opts(argc, argv);
+	if (err)
+		exit(1);
 
 	signal(SIGSEGV, sig);
 	signal(SIGINT, sig);
 	signal(SIGTERM, sig);
 
-	if( (tsdevice = getenv("TSLIB_TSDEVICE")) != NULL ) {
-		ts = ts_open(tsdevice,0);
-	} else {
-		if (!(ts = ts_open("/dev/input/event0", 0)))
-			ts = ts_open("/dev/touchscreen/ucb1x00", 0);
-	}
-
-	if (!ts) {
-		perror("ts_open");
-		exit(1);
-	}
-
-	if (ts_config(ts)) {
-		perror("ts_config");
+	/* get xres, yres */
+	if (open_framebuffer()) {
+		close_framebuffer();
 		exit(1);
 	}
 
-	if (open_framebuffer()) {
-		close_framebuffer();
+	ts = ts_open_config(0, xres, yres);
+	if (!ts) {
+		perror("ts_open_config");
 		exit(1);
 	}
 
@@ -199,7 +246,7 @@ int main()
 					quit_pressed = 1;
 				}
 
-		printf("%ld.%06ld: %6d %6d %6d\n", samp.tv.tv_sec, samp.tv.tv_usec,
+		if (0) printf("%ld.%06ld: %6d %6d %6d\n", samp.tv.tv_sec, samp.tv.tv_usec,
 			samp.x, samp.y, samp.pressure);
 
 		if (samp.pressure > 0) {
-- 
2.11.0

